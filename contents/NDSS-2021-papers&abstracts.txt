{"all the numbers are us: large-scale abuse of contact discovery in mobile messengers": "contact discovery allows users of mobile messengers to conveniently connect with people in their address book. in this work, we demonstrate that severe privacy issues exist in currently deployed contact discovery methods.\nour study of three popular mobile messengers (whatsapp, signal, and telegram) shows that, contrary to expectations, large-scale crawling attacks are (still) possible. using an accurate database of mobile phone number prefixes and very few resources, we have queried 10% of us mobile phone numbers for whatsapp and 100% for signal. for telegram we find that its api exposes a wide range of sensitive information, even about numbers not registered with the service. we present interesting (cross-messenger) usage statistics, which also reveal that very few users change the default privacy settings. regarding mitigations, we propose novel techniques to significantly limit the feasibility of our crawling attacks, especially a new incremental contact discovery scheme that strictly improves over signal's current approach.\nfurthermore, we show that currently deployed hashing-based contact discovery protocols are severely broken by comparing three methods for efficient hash reversal of mobile phone numbers. for this, we also propose a significantly improved rainbow table construction for non-uniformly distributed inputs that is of independent interest.", "as strong as its weakest link: how to break blockchain dapps at rpc service": "modern blockchains have evolved from cryptocurrency substrates to trust-decentralization platforms, supporting a wider variety of decentralized applications known as dapps. blockchain remote procedure call (rpc) services emerge as an intermediary connecting the dapps to a blockchain network. in this work, we identify the free contract-execution capabilities that widely exist in blockchain rpcs as a vulnerability of denial of service (dos) and present the doers attack, a denial of ethereum rpc service that incurs zero ether cost to the attacker.\nto understand the doers exploitability in the wild, we conduct a systematic measurement study on nine real-world rpc services which control most dapp clients' connection to the ethereum mainnet. in particular, we propose a novel measurement technique based on orphan transactions to discover the previously unknown behaviors inside the blackbox rpc services, including load balancing and gas limiting. further doers strategies are proposed to evade the protection intended by these behaviors.\nwe evaluate the effectiveness of doers attacks on deployed rpc services with minimal service interruption. the result shows that all the nine services tested (as of apr. 2020) are vulnerable to doers attacks that can result in the service latency increased by $2.1xsim{}50x$. some of these attacks require only a single request. in addition, on a local ethereum node protected by a very restrictive limit of $0.65$ block gas, sending 150 doers requests per second can slow down the block synchronization of the victim node by $91%$.\nwe propose mitigation techniques against doers without dropping service usability, via unpredictable load balancing, performance anomaly detection, and others. these techniques can be integrated into a rpc service transparently to its clients.", "awakening the web's sleeper agents: misusing service workers for privacy leakage": "service workers are a powerful technology supported by all major modern browsers that can improve users' browsing experience by offering capabilities similar to those of native applications. while they are gaining significant traction in the developer community, they have not received much scrutiny from security researchers. in this paper, we explore the capabilities and inner workings of service workers and conduct the first comprehensive large-scale study of their api use in the wild. subsequently, we show how attackers can exploit the strategic placement of service workers for history-sniffing in most major browsers, including chrome and firefox. we demonstrate two novel history-sniffing attacks that exploit the lack of appropriate isolation in these browsers, including a non-destructive cache-based version. next, we present a series of use cases that illustrate how our techniques enable privacy-invasive attacks that can infer sensitive application-level information, such as a user's social graph. we have disclosed our techniques to all vulnerable vendors, prompting the chromium team to explore a redesign of their site isolation mechanisms for defending against our attacks.  we also propose a countermeasure that can be incorporated by websites to protect their users, and develop a tool that streamlines its deployment, thus facilitating adoption at a large scale.  overall, our work presents a cautionary tale on the severe risks of browsers deploying new features without an in-depth evaluation of their security and privacy implications.", "bringing balance to the force: dynamic analysis of the android application framework": "android's application framework plays a crucial part in protecting users' private data and the system integrity. consequently, it has been the target of various prior works that analyzed its security policy and enforcement. those works uncovered different security problems, including incomplete documentation, permission re-delegation within the framework, and inconsistencies in access control. however, all but one of those prior works were based on static code analysis. thus, their results provide a one-sided view that inherits the limitations and drawbacks of applying static analysis to the vast, complex code base of the application framework. even more, the performances of different security applications---including malware classification and least-privileged apps---depend on those analysis results, but those applications are currently tarnished by imprecise and incomplete results as a consequence of this imbalanced analysis methodology. to complement and refine this methodology and consequently improve the applications that are dependent on it, we add dynamic analysis of the application framework to the current research landscape and demonstrate the necessity of this move for improving the quality of prior results and advancing the field. applying our solution, called dynamo, to four prominent use-cases from the literature and taking a synoptical view on the results, we verify but also refute and extend the existing results of prior static analysis solutions. from the manual investigation of the root causes of discrepancies between results, we draw new insights and expert knowledge that can be valuable in improving both static and dynamic testing of the application framework.", "c^2sr: cybercrime scene reconstruction for post-mortem forensic analysis": "cybercrime scene reconstruction that aims to reconstruct a previous execution of the cyber attack delivery process is an important capability for cyber forensics (e.g., post mortem analysis of the cyber attack executions). unfortunately, existing techniques such as log-based forensics or record-and-replay techniques are not suitable to handle complex and long-running modern applications for cybercrime scene reconstruction and post mortem forensic analysis. specifically, log-based cyber forensics techniques often suffer from a lack of inspection capability and do not provide details of how the attack unfolded. record-and-replay techniques impose significant runtime overhead, often require significant modifications on end-user systems, and demand to replay the entire recorded execution from the beginning. in this paper, we propose c^2sr, a novel technique that can reconstruct an attack delivery chain (i.e., cybercrime scene) for post-mortem forensic analysis. it provides a highly desired capability: interactable partial execution reconstruction. in particular, it reproduces a partial execution of interest from a large execution trace of a long-running program. the reconstructed execution is also interactable, allowing forensic analysts to leverage debugging and analysis tools that did not exist on the recorded machine. the key intuition behind c^2sr is partitioning an execution trace by resources and reproducing resource accesses that are consistent with the original execution. it tolerates user interactions required for inspections that do not cause inconsistent resource accesses. our evaluation results on 26 real-world programs show that c^2sr has low runtime overhead (less than 5.47%) and acceptable space overhead. we also demonstrate with four realistic attack scenarios that c^2sr successfully reconstructs partial executions of long-running applications such as web browsers, and it can remarkably reduce the user's efforts to understand the incident.", "deceptive deletions for protecting withdrawn posts on social media platforms": "over-sharing poorly-worded thoughts and personal information is prevalent on online social platforms. in many of these cases, users regret posting such content. to retrospectively rectify these errors in users' sharing decisions, most platforms offer (deletion) mechanisms to withdraw the content, and social media users often utilize them. ironically and perhaps unfortunately, these deletions make users more susceptible to privacy violations by malicious actors who specifically hunt post deletions at large scale. the reason for such hunting is simple: deleting a post acts as a powerful signal that the post might be damaging to its owner. today, multiple archival services are already scanning social media for these deleted posts. moreover, as we demonstrate in this work, powerful machine learning models can detect damaging deletions at scale.\ntowards restraining such a global adversary against users' right to be forgotten, we introduce deceptive deletion, a decoy mechanism that minimizes the adversarial advantage. our mechanism injects decoy deletions, hence creating a two-player minmax game between an adversary that seeks to classify damaging content among the deleted posts and a challenger that employs decoy deletions to masquerade real damaging deletions. we formalize the deceptive game between the two players, determine conditions under which either the adversary or the challenger provably wins the game, and discuss the scenarios in-between these two extremes. we apply the deceptive deletion mechanism to a real-world task on twitter: hiding damaging tweet deletions. we show that a powerful global adversary can be beaten by a powerful challenger, raising the bar significantly and giving a glimmer of hope in the ability to be really forgotten on social platforms.", "dove: a data-oblivious virtual environment": "users can improve the security of remote communications by using trusted execution environments (tees) to protect against direct introspection and tampering of sensitive data. this can even be done with applications coded in high-level languages with complex programming stacks such as r, python, and ruby. however, this creates a trade-off between programming convenience versus the risk of attacks using microarchitectural side channels. \nin this paper, we argue that it is possible to address this problem for important applications by instrumenting a complex programming environment (like r) to produce a data-oblivious transcript (dot) that is explicitly designed to support computation that excludes side channels. such a transcript is then evaluated on a trusted execution environment (tee) containing the sensitive data using a small trusted computing base called the data-oblivious virtual environment (dove).\nto motivate the problem, we demonstrate a number of subtle side-channel vulnerabilities in the r language. we then provide an illustrative design and implementation of dove for r, creating the first side-channel resistant r programming stack. we demonstrate that the two-phase architecture provided by dot generation and dove evaluation can provide practical support for complex programming languages with usable performance and high security assurances against side channels.", "evading voltage-based intrusion detection on automotive can": "the controller area network (can) is widely adopted in modern automobiles to enable communications among in-vehicle electronic control units (ecus). lacking mainstream network security capabilities due to resource constraints, the can is susceptible to the ecu masquerade attack in which a compromised (attacker) ecu impersonates an uncompromised (victim) ecu and spoofs the latter\u2019s can messages. a cost-effective state-of-the-art defense against such attacks is the can bus voltage-based intrusion detection system (vids), which identifies the source of each message using its voltage fingerprint on the bus. since the voltage fingerprint emanates from an ecu's hardware characteristics, an attacker ecu by itself cannot controllably modify it. as such, vids has been proved effective in detecting masquerade attacks that each involve a single attacker.\nin this paper, we discover a novel voltage corruption tactic that leverages the capabilities of two compromised ecus (i.e., an attacker ecu working in tandem with an accomplice ecu) to corrupt the bus voltages recorded by the vids. by exploiting this tactic along with the fundamental deficiencies of the can protocol, we propose a novel masquerade attack called duet, which evades all existing vids irrespective of the features and classification algorithms employed in them. duet follows a two-stage attack strategy to first manipulate a victim ecu\u2019s voltage fingerprint during vids retraining mode, and then impersonate the manipulated fingerprint during vids operation mode. our evaluation of duet on real can buses (including three in two real cars) demonstrates an impersonation success rate of at least 90% in evading two state-of-the-art vids.\nfinally, to mitigate ecu masquerade attacks, we advocate the development of cost-effective defenses that break away from the \"attack vs. ids\" arms race. we propose a lightweight defense called raid, which enables each ecu to make protocol-compatible modifications in its frame format generating a unique dialect (spoken by ecus) during vids retraining mode. raid prevents corruption of ecus\u2019 voltage fingerprints, and re-enables vids to detect all ecu masquerade attacks including duet.", "flexsealing bgp against route leaks: peerlock active measurement and analysis": "bgp route leaks frequently precipitate serious disruptions to inter-domain routing. these incidents have plagued the internet for decades while deployment and usability issues cripple efforts to mitigate the problem. peerlock, introduced in 2016, addresses route leaks with a new approach. peerlock enables filtering agreements between transit providers to protect their own networks without the need for broad cooperation or a trust infrastructure. we outline the peerlock system and one variant, peerlock-lite, and conduct live internet experiments to measure their deployment on the control plane. our measurements find evidence for significant peerlock protection between tier 1 networks in the peering clique, where 48% of potential peerlock filters are deployed, and reveal that many other networks also deploy filters against tier 1 leaks. to guide further deployment, we also quantify peerlock\u2019s impact on route leaks both at currently observed levels and under hypothetical future deployment scenarios via bgp simulation. these experiments reveal present peerlock deployment restricts tier 1 leak export to 10% or fewer networks for 40% of simulated leaks. strategic additional peerlock-lite deployment at all large isps (<1% of all networks), in tandem with peerlock within the peering clique as deployed, completely mitigates about 80% of simulated tier 1 route leaks.", "forward and backward private conjunctive searchable symmetric encryption": "dynamic searchable symmetric encryption (sse) supports updates and keyword searches in tandem on outsourced symmetrically encrypted data, while aiming to minimize the information revealed to the (untrusted) host server. the literature on dynamic sse has identified two crucial security properties in this regard - emph{forward} and emph{backward} privacy. forward privacy makes it hard for the server to correlate an update operation with previously executed search operations. backward privacy limits the amount of information learnt by the server about documents that have already been deleted from the database.\nto date, work on forward and backward private sse has focused mainly on single keyword search. however, for any sse scheme to be truly practical, it should at least support conjunctive keyword search. in this setting, most prior sse constructions with sub-linear search complexity do not support dynamic databases. the only exception is the scheme of kamara and moataz (eurocrypt'17); however it only achieves forward privacy. achieving emph{both} forward and backward privacy, which is the most desirable security notion for any dynamic sse scheme, has remained open in the setting of conjunctive keyword search.\nin this work, we develop the first forward and backward private sse scheme for conjunctive keyword searches. our proposed scheme, called oblivious dynamic cross tags (or odxt in short), scales to very large arbitrarily-structured databases (including both attribute-value and free-text databases). odxt provides a realistic trade-off between performance and security by efficiently supporting fast updates and conjunctive keyword searches over very large databases, while incurring only moderate access pattern leakages to the server that conform to existing notions of forward and backward privacy. we precisely define the leakage profile of odxt, and present a detailed formal analysis of its security. we then demonstrate the practicality of odxt by developing a prototype implementation and evaluating its performance on real world databases containing millions of documents.", "from whois to whowas: a large-scale measurement study of domain registration privacy under the gdpr": "when a domain is registered, information about the registrants and other related personnel is recorded by whois databases owned by registrars or registries (called whois providers jointly), which are open to public inquiries. however, due to the enforcement of the european union\u2019s general data protection regulation (gdpr), certain whois data (i.e., the records about eea, or the european economic area, registrants) needs to be redacted before being released to the public. anecdotally, it was reported that actions have been taken by some whois providers. yet, so far there is no systematic study to quantify the changes made by the whois providers in response to the gdpr, their strategies for data redaction and impact on other applications relying on whois data.\nin this study, we report the first large-scale measurement study to answer these questions, in hopes of guiding the enforcement of the gdpr and identifying pitfalls during compliance. this study is made possible by analyzing a collection of 1.2 billion whois records spanning two years. to automate the analysis tasks, we build a new system gcchecker based on unsupervised learning, which assigns a compliance score to a provider. our findings of whois gdpr compliance are multi-fold. to highlight a few, we discover that the gdpr has a profound impact on whois, with over 85% surveyed large whois providers redacting eea records at scale. surprisingly, over 60% large whois data providers also redact non-eea records. a variety of compliance flaws like incomplete redaction are also identified. the impact on security applications is prominent and redesign might be needed. we believe different communities (security, domain and legal) should work together to solve the issues for better whois privacy and utility.", "hey alexa, is this skill safe?: taking a closer look at the alexa skill ecosystem": "amazon's voice-based assistant, alexa, enables users to directly interact with various web services through natural language dialogues. it provides developers with the option to create third-party applications (known as skills) to run on top of alexa. while such applications ease users' interaction with smart devices and bolster a number of additional services, they also raise security and privacy concerns due to the personal setting they operate in. this paper aims to perform a systematic analysis of the alexa skill ecosystem. we perform the first large-scale analysis of alexa skills, obtained from seven different skill stores totaling to 90,194 unique skills. our analysis reveals several limitations that exist in the current skill vetting process. we show that not only can a malicious user publish a skill under any arbitrary developer/company name, but she can also make backend code changes after approval to coax users into revealing unwanted information. we, next, formalize the different skill-squatting techniques and evaluate the efficacy of such techniques. we find that while certain approaches are more favorable than others, there is no substantial abuse of skill squatting in the real world. lastly, we study the prevalence of privacy policies across different categories of skill, and more importantly the policy content of skills that use the alexa permission model to access sensitive user data. we find that around 23.3% of such skills do not fully disclose the data types associated with the permissions requested. we conclude by providing some suggestions for strengthening the overall ecosystem, and thereby enhance transparency for end-users.", "let\u2019s stride blindfolded in a forest: sublinear multi-client decision trees evaluation": "decision trees are popular machine-learning classification models due to their simplicity and effectiveness. tai et al. (esorics '17) propose a privacy-preserving decision-tree evaluation protocol purely based on additive homomorphic encryption, without introducing dummy nodes for hiding the tree structure, but it runs a secure comparison for each decision node, resulting in linear complexity. later protocols (dbsec '18, pets '19) achieve sublinear (client-side) complexity, yet the server-side path evaluation requires oblivious transfer among $2^d$ real and dummy nodes even for a sparse tree of depth $d$ to hide the tree structure.\nthis paper aims for the best of both worlds and hence the most lightweight protocol to date. our complete-tree protocol can be easily extended to the sparse-tree setting and the reusable outsourcing setting: a model owner (resp. client) can outsource the decision tree (resp. attributes) to two non-colluding servers for classifications. the outsourced extension supports multi-client joint evaluation, which is the first of its kind without using multi-key fully-homomorphic encryption (tdsc '19). we also extend our protocol for achieving privacy against malicious adversaries.\nour experiments compare in various network settings our offline and online communication costs and the online computation time with the prior sublinear protocol of tueno et al. (pets '19) and $o(1)$-round linear protocols of kiss et al. (pets '19), which can be seen as garbled circuit variants of tai et al.'s. our protocols are shown to be desirable for iot-like scenarios with weak clients and big-data scenarios with high-dimensional feature vectors.", "more than a fair share: network data remanence attacks against secret sharing-based schemes": "with progress toward a practical quantum computer has come an increasingly rapid search for quantum-safe, secure communication schemes that do not rely on discrete logarithm or factorization problems. one such encryption scheme, multi-path switching with secret sharing (msss), combines secret sharing with multi-path switching to achieve security as long as the adversary does not have global observability of all paths and thus cannot capture enough shares to reconstruct messages. msss assumes that sending a share on a path is an atomic operation and all paths have the same delay.\nwe identify a side-channel vulnerability for msss, created by the fact that in real networks, sending a share is not an atomic operation as paths have multiple hops and different delays. this channel, referred to as network data remanence (ndr), is present in all schemes like msss whose security relies on path atomicity and all paths having same delay. we demonstrate the presence of ndr in a physical testbed. we then identify two new attacks that exploit the side- channel, referred to as ndr blind and ndr planned, propose an analytical model to analyze the attacks, and demonstrate them using an implementation of msss based on the onos sdn controller. finally, we present a countermeasure for the attacks and show its effectiveness in simulations and mininet experiments.", "obfuscated access and search patterns in searchable encryption": "searchable symmetric encryption (sse) allows a data owner to securely outsource its encrypted data to a cloud server while maintaining the ability to search over it and retrieve matched documents. most existing sse schemes leak which documents are accessed per query, i.e., the so-called access pattern, and thus are vulnerable to attacks that can recover the database or the queried keywords. current techniques that fully hide access patterns, such as oram or pir, suffer from heavy communication or computational costs, and are not designed with search capabilities in mind. recently, chen et al. (infocom'18) proposed an obfuscation framework for sse that protects the access pattern in a differentially private way with a reasonable utility cost. however, this scheme always produces the same obfuscated access pattern when querying for the same keyword, and thus leaks the so-called search pattern, i.e., how many times a certain query is performed. this leakage makes the proposal vulnerable to certain database and query recovery attacks.\nin this paper, we propose osse (obfuscated sse), an sse scheme that obfuscates the access pattern independently for each query performed. this in turn hides the search pattern and makes our scheme resistant against attacks that rely on this leakage. given certain reasonable assumptions on the database and query distribution, our scheme has smaller communication overhead than oram-based sse. furthermore, our scheme works in a single communication round and requires very small constant client-side storage. our empirical evaluation shows that osse is highly effective at protecting against different query recovery attacks while keeping a reasonable utility level. our protocol provides significantly more protection than the proposal by chen et al. against some state-of-the-art attacks, which demonstrates the importance of hiding search patterns in designing effective privacy-preserving sse schemes.", "pop and push: demystifying and defending against (mach) port-oriented programming": "apple devices (e.g., iphone, macbook, ipad, and apple watch) are high value targets for attackers. although these devices use different operating systems (e.g., ios, macos, ipados, watchos, and tvos), they are all based on a hybrid kernel called xnu. existing attacks demonstrated that vulnerabilities in xnu could be exploited to escalate privileges and jailbreak devices. to mitigate these threats, multiple security mechanisms have been deployed in latest systems.\nin this paper, we first perform a systematic assessment of deployed mitigations by apple, and demonstrate that most of them can be bypassed through corrupting a special type of kernel objects, i.e., mach port objects. we summarize this type of attack as (mach) port object-oriented programming (pop). accordingly, we define multiple attack primitives to launch the attack and demonstrate realistic scenarios to achieve full memory manipulation on recently released systems (i.e., ios 13 and macos 10.15). to defend against pop, we propose the port ultra-shield (push) system to reduce the number of unprotected mach port objects. specifically, push automatically locates potential pop primitives and instruments related system calls to enforce the integrity of mach port kernel objects. it does not require system modifications and only introduces 2% runtime overhead. the push framework has been deployed on more than 40,000 macos devices in a leading company. the evaluation of 18 public exploits and one zero-day exploit detected by our system demonstrated the effectiveness of push. we believe that the proposed framework will facilitate the design and implementation of a more secure xnu kernel.", "processing dangerous paths \u2013 on security and privacy of the portable document format": "pdf is the de-facto standard for document exchange. it is common to open pdf files from potentially untrusted sources such as email attachments or downloaded from the internet. in this work, we perform an in-depth analysis of the capabilities of malicious pdf documents. instead of focusing on implementation bugs, we abuse legitimate features of the pdf standard itself by systematically identifying dangerous paths in the pdf file structure. these dangerous paths lead to attacks that we categorize into four generic classes: (1) denial-of-service attacks affecting the host that processes the document. (2) information disclosure attacks leaking personal data out of the victim\u2019s computer. (3) data manipulation on the victim\u2019s system. (4) code execution on the victim\u2019s machine. an evaluation of 28 popular pdf processing applications shows that 26 of them are vulnerable at least one attack. finally, we propose a methodology to protect against attacks based on pdf features systematically.", "reining in the web's inconsistencies with site policy": "over the years, browsers have adopted an ever-increasing number of client-enforced security policies deployed by means of http headers. such mechanisms are fundamental for web application security, and usually deployed on a per-page basis. this, however, enables inconsistencies, as different pages within the same security boundaries (in form of origins or sites) can express conflicting security requirements. in this paper, we formalize inconsistencies for cookie security attributes, csp, and hsts, and then quantify the magnitude and impact of inconsistencies at scale by crawling 15,000 popular sites. we show numerous sites endanger their own security by omission or misconfiguration of the aforementioned mechanisms, which lead to unnecessary exposure to xss, cookie theft and hsts deactivation. we then use our data to analyse to which extent the recent *origin policy* proposal can fix the problem of inconsistencies. unfortunately, we conclude that the current origin policy design suffers from major shortcomings which limit its practical applicability to address security inconsistencies, while catering to the need of real-world sites. based on these insights, we propose site policy, an extension of origin policy designed to overcome the shortcomings of origin policy and to make any insecurity explicit.", "rosita: towards automatic elimination of power-analysis leakage in ciphers": "since their introduction over two decades ago, side-channel attacks have presented a serious security threat. while many ciphers\u2019 implementations employ masking techniques to protect against such attacks, they often leak secret information due to unintended interactions in the hardware. we present rosita, a code rewrite engine that uses a leakage emulator which we amend to correctly emulate the micro-architecture of a target system. we use rosita to automatically protect masked implementations of aes, chacha, and xoodoo. for aes and xoodoo, we show the absence of observable leakage at 1000000 traces with less than 21% penalty to the performance. for chacha, which has significantly more leakage, rosita eliminates over 99% of the leakage, at a performance cost of 64%", "screen gleaning: a screen reading tempest attack on mobile devices exploiting an electromagnetic side channel": "we introduce emph{screen gleaning}, a tempest attack in which the screen of a mobile device is read without a visual line of sight, revealing sensitive information displayed on the phone screen. the screen gleaning attack uses an antenna and a software-defined radio (sdr) to pick up the electromagnetic signal that the device sends to the screen to display, e.g., a message with a security code. this special equipment makes it possible to recreate the signal as a gray-scale image, which we refer to as an emph{emage}. here, we show that it can be used to read a security code. the screen gleaning attack is challenging because it is often impossible for a human viewer to interpret the emage directly. we show that this challenge can be addressed with machine learning, specifically, a deep learning classifier. screen gleaning will become increasingly serious as sdrs and deep learning continue to rapidly advance. in this paper, we demonstrate the security code attack and we propose a testbed that provides a standard setup in which screen gleaning could be tested with different attacker models. finally, we analyze the dimensions of screen gleaning attacker models and discuss possible countermeasures with the potential to address them.", "the abuser inside apps: finding the culprit committing mobile ad fraud": "mobile ad fraud is a significant threat that victimizes app publishers and their users, thereby undermining the ecosystem of app markets. prior works on detecting mobile ad fraud have focused on constructing predefined test scenarios that preclude user involvement in identifying ad fraud. however, due to their dependence on contextual testing environments, these works have neglected to track which app modules and which user interactions are responsible for observed ad fraud.\nto address these shortcomings, this paper presents the design and implementation of frauddetective, a dynamic testing framework that identifies ad fraud activities. frauddetective focuses on identifying fraudulent activities that originate without any user interactions. frauddetective computes a full stack trace from an observed ad fraud activity to a user event by connecting fragmented multiple stack traces, thus generating the causal relationships between user inputs and the observed fraudulent activity. we revised an android open source project (aosp) to emit detected ad fraud activities along with their full stack traces, which help pinpoint the app modules responsible for the observed fraud activities. we evaluate frauddetective on 48,172 apps from google play store. frauddetective reports that 74 apps are responsible for 34,453 ad fraud activities and find that 98.6% of the fraudulent behaviors originate from embedded third-party ad libraries. our evaluation demonstrates that frauddetective is capable of accurately identifying ad fraud via reasoning based on observed suspicious behaviors without user interactions. the experimental results also yield the new insight that abusive ad service providers harness their ad libraries to actively engage in committing ad fraud.", "towards measuring supply chain attacks on package managers for interpreted languages": "package managers have become a vital part of the modern software development process. they allow developers to reuse third-party code, share their own code, minimize their codebase, and simplify the build process. however, recent reports showed that package managers have been abused by attackers to distribute malware, posing significant security risks to developers and end-users. for example, eslint-scope, a package with millions of weekly downloads in npm, was compromised to steal credentials from developers. to understand the security gaps and the misplaced trust that make recent supply chain attacks possible, we propose a comparative framework to qualitatively assess the functional and security features of package managers for interpreted languages. based on qualitative assessment, we apply well-known program analysis techniques such as metadata, static, and dynamic analysis to study registry abuse. our initial efforts found 339 new malicious packages that we reported to the registries for removal. the package manager maintainers confirmed 278 (82%) from the 339 reported packages where three of them had more than 100,000 downloads. for these packages we were issued official cve numbers to help expedite the removal of these packages from infected victims. we outline the challenges of tailoring program analysis tools to interpreted languages and release our pipeline as a reference point for the community to build on and help in securing the software supply chain.", "xda: accurate, robust disassembly with transfer learning": "accurate and robust disassembly of stripped binaries is challenging. the root of the difficulty is that high-level structures, such as instruction and function boundaries, are absent in stripped binaries and must be recovered based on incomplete information. current disassembly approaches rely on heuristics or simple pattern matching to approximate the recovery, but these methods are often inaccurate and brittle, especially across different compiler optimizations. \nwe present xda, a transfer-learning-based disassembly framework that learns different contextual dependencies present in machine code and transfers this knowledge for accurate and robust disassembly. we design a self-supervised learning task motivated by masked language modeling to learn interactions among byte sequences in binaries. the outputs from this task are byte embeddings that encode sophisticated contextual dependencies between input binaries' byte tokens, which can then be finetuned for downstream disassembly tasks.\nwe evaluate xda's performance on two disassembly tasks, recovering function boundaries and assembly instructions, on a collection of 3,121 binaries taken from spec cpu2017, spec cpu2006, and the bap corpus. the binaries are compiled by gcc, icc, and msvc on x86/x64 windows and linux platforms over 4 optimization levels. xda achieves 99.0% and 99.7% f1 score at recovering function boundaries and instructions, respectively, surpassing the previous state-of-the-art on both tasks. it also maintains speed on par with the fastest ml-based approach and is up to 38x faster than hand-written disassemblers like ida pro. we release the code of xda at https://github.com/cumlsec/xda.", "zoom on the keystrokes: exploiting video calls for keystroke inference attacks": "due to recent world events, video calls have become the new norm for both personal and professional remote communication. however, if a participant in a video call is not careful, he/she can reveal his/her private information to others in the call. in this paper, we design and evaluate an attack framework to infer one type of such private information from the video stream of a call -- keystrokes, i.e., text typed during the call. we evaluate our video-based keystroke inference framework using different experimental settings, such as different webcams, video resolutions, keyboards, clothing, and backgrounds. our high keystroke inference accuracies under commonly occurring experimental settings highlight the need for awareness and countermeasures against such attacks. consequently, we also propose and evaluate effective mitigation techniques that can automatically protect users when they type during a video call.", "a devil of a time: how vulnerable is ntp to malicious timeservers?": "the network time protocol (ntp) synchronizes time across computer systems over the internet and plays a crucial role in guaranteeing the correctness and security of many internet applications. unfortunately, ntp is vulnerable to so called time shifting attacks. this has motivated proposals and standardization efforts for authenticating ntp communications and for securing ntp textit{clients}. we observe, however, that, even with such solutions in place, ntp remains highly exposed to attacks by malicious textit{timeservers}. we explore the implications for time computation of two attack strategies: (1) compromising textit{existing} ntp timeservers, and (2) injecting textit{new} timeservers into the ntp timeserver pool. we first show that by gaining control over fairly few existing timeservers, an textit{opportunistic} attacker can shift time at state-level or even continent-level scale. we then demonstrate that injecting new timeservers with disproportionate influence into the ntp timeserver pool is alarmingly simple, and can be leveraged for launching both large-scale textit{opportunistic} attacks, and strategic, textit{targeted} attacks. we discuss a promising approach for mitigating such attacks.", "a formal analysis of the fido uaf protocol": "the fido protocol suite aims at allowing users to log in to remote services with a local and trusted authenticator. with fido, relying services do not need to store user-chosen secrets or their hashes, which eliminates a major attack surface for e-business. given its increasing popularity, it is imperative to formally analyze whether the security promises of fido hold. in this paper, we present a comprehensive and formal verification of the fido uaf protocol by formalizing its security assumptions and goals and modeling the protocol under different scenarios in proverif. our analysis identifies the minimal security assumptions required for each of the security goals of fido uaf to hold. we confirm previously manually discovered vulnerabilities in an automated way and disclose several new attacks. guided by the formal verification results we also discovered 2 practical attacks on 2 popular android fido apps, which we responsibly disclosed to the vendors. in addition, we offer several concrete recommendations to fix the identified problems and weaknesses in the protocol.", "alchemist: fusing application and audit logs for precise attack provenance without instrumentation": "cyber-attacks are becoming more persistent and complex. most state-of-the-art attack forensics techniques either require annotating and instrumenting software applications or rely on high quality execution profile to serve as the basis for anomaly detection. we propose a novel attack forensics technique alchemist. it is based on  the  observations  that  built-in application logs provide critical high-level semantics and audit log provides low-level fine-grained information; and the two share a  lot  of  common  elements. alchemist is  hence  a  log  fusion technique  that  couples  application  logs  and  audit  log  to  derive critical attack information invisible in either log. it is based on a relational reasoning engine datalog and features the capabilities of inferring new relations such as the task structure of execution(e.g.,  tabs in firefox),  especially  in the  presence of  complex asynchronous execution models, and high-level dependencies between log  events.  our  evaluation  on  15  popular  applications  including firefox, chromium, and openoffice, and 14 apt attacks from the literature demonstrates that although alchemist does not require instrumentation,  it  is  highly  effective  in  partitioning  execution to  autonomous  tasks(in  order  to  avoid  bogus  dependencies) and  deriving  precise  attack  provenance  graphs,  with  very  small overhead. it also outperforms nodoze and omegalog, two state-of-art  techniques  that  do  not  require  instrumentation.", "basespec: comparative analysis of baseband software and cellular specifications for l3 protocols": "cellular basebands play a crucial role in mobile communication. however, it is significantly challenging to assess their security for several reasons. manual analysis is inevitable because of the obscurity and complexity of baseband firmware; however, such analysis requires repetitive efforts to cover diverse models or versions. automating the analysis is also non-trivial because the firmware is significantly large and contains numerous functions associated with complex cellular protocols. therefore, existing approaches on baseband analysis are limited to only a couple of models or versions within a single vendor. in this paper, we propose a novel approach named basespec, which performs a comparative analysis of baseband software and cellular specifications. by leveraging the standardized message structures in the specification, basespec inspects the message structures implemented in the baseband software systematically. it requires a manual yet one-time analysis effort to determine how the message structures are embedded in target firmware. then, basespec compares the extracted message structures with those in the specification syntactically and semantically, and finally, it reports mismatches. these mismatches indicate the developer mistakes, which break the compliance of the baseband with the specification, or they imply potential vulnerabilities. we evaluated basespec with 18 baseband firmware images of 9 models from one of the top three vendors and found hundreds of mismatches. by analyzing these mismatches, we discovered 9 erroneous cases: 5 functional errors and 4 memory-related vulnerabilities. notably, two of these are critical remote code execution 0-days. moreover, we applied basespec to 3 models from another vendor, and basespec found multiple mismatches, two of which led us to discover a buffer overflow bug.", "bitcontracts: supporting smart contracts in legacy blockchains": "in this paper we propose bitcontracts, a novel solution that enables secure and efficient execution of generic smart contracts on top of unmodified legacy cryptocurrencies like bitcoin that do not support contracts natively. the starting point of our solution is an off-chain execution model, where the contract's issuers appoints a set of service providers to execute the contract's code. the contract's execution results are accepted if a quorum of service providers reports the same result and clients are free to choose which such contracts they trust and use. the main technical contribution of this paper is how to realize such a trust model securely and efficiently without modifying the underlying blockchain. \nwe also identify a set of generic properties that a blockchain system must support so that expressive smart contracts can be added safely, and analyze popular existing blockchains based on these criteria.", "chancel: efficient multi-client isolation under adversarial programs": "intel sgx aims to provide the confidentiality of user data on untrusted cloud machines. however, applications that process confidential user data may contain bugs that leak information or be programmed maliciously to collect user data. existing research that attempts to solve this problem does not consider multi-client isolation in a single enclave. we show that by not supporting such isolation, they incur considerable slowdown when concurrently processing multiple clients in different processes, due to the limitations of sgx. \nthis paper proposes chancel, a sandbox designed for multi-client isolation within a single sgx enclave. in particular, chancel allows a program\u2019s threads to access both a per-thread memory region and a shared read-only memory region while servicing requests. each thread handles requests from a single client at a time and is isolated from other threads, using a multi-client software fault isolation (mcsfi) scheme. furthermore, chancel supports various in-enclave services such as an in-memory file system and shielded client communication to ensure complete mediation of the program\u2019s interactions with the outside world. we implemented chancel and evaluated it on sgx hardware using both micro-benchmarks and realistic target scenarios, including private information retrieval and product recommendation services. our results show that chancel outperforms a baseline multi-process sandbox between 4.06\u221253.70\u00d7 on micro-benchmarks and 0.02 \u2212 21.18\u00d7 on realistic workloads while providing strong security guarantees.", "cv-inspector: towards automating detection of adblock circumvention": "the adblocking arms race has escalated over the last few years. an entire new ecosystem of circumvention (cv) services has recently emerged that aims to bypass adblockers by obfuscating site content, making it difficult for adblocking filter lists to distinguish between ads and functional content. in this paper, we investigate recent anti-circumvention efforts by the adblocking community that leverage custom filter lists. in particular, we analyze the anti-circumvention filter list (acvl), which supports advanced filter rules with enriched syntax and capabilities designed specifically to counter circumvention. we show that keeping acvl rules up-to-date requires expert list curators to continuously monitor sites known to employ cv services and to discover new such sites in the wild \u2014 both tasks require considerable manual effort. to help automate and scale acvl curation, we develop cv-inspector, a machine learning approach for automatically detecting adblock circumvention using differential execution analysis. we show that cv-inspector achieves 93% accuracy in detecting sites that successfully circumvent adblockers. we deploy cv-inspector on top-20k sites to discover the sites that employ circumvention in the wild.we further apply cv-inspector to a list of sites that are known to utilize circumvention and are closely monitored by acvl authors. we demonstrate that cv-inspector reduces the human labeling effort by 98%, which removes a major bottleneck for acvl authors. our work is the first large-scale study of the state of the adblock circumvention arms race, and makes an important step towards automating anti-cv efforts.", "data poisoning attacks to deep learning based recommender systems": "recommender systems play a crucial role in helping users to find their interested information in various web services such as amazon, youtube, and google news. various recommender systems, ranging from neighborhood-based, association-rule-based, matrix-factorization-based, to deep learning based, have been developed and deployed in industry. among them, deep learning based recommender systems become increasingly popular due to their superior performance. \nin this work, we conduct the first systematic study on data poisoning attacks to deep learning based recommender systems. an attacker's goal is to manipulate a recommender system such that the attacker-chosen target items are recommended to many users. to achieve this goal, our attack injects fake users with carefully crafted ratings to a recommender system. specifically, we formulate our attack as an optimization problem, such that the injected ratings would maximize the number of normal users to whom the target items are recommended. however, it is challenging to solve the optimization problem because it is a non-convex integer programming problem. to address the challenge, we develop multiple techniques to approximately solve the optimization problem. our experimental results on three real-world datasets, including small and large datasets, show that our attack is effective and outperforms existing attacks. moreover, we attempt to detect fake users via statistical analysis of the rating patterns of normal and fake users. our results show that our attack is still effective and outperforms existing attacks even if such a detector is deployed.", "detecting kernel memory leaks in specialized modules with ownership reasoning": "the kernel space is shared by hardware and all processes, so its memory usage is more limited, and memory is harder to reclaim, compared to user-space memory; as a result, memory leaks in the kernel can easily lead to high-impact denial of service. the problem is particularly critical in long-running servers. kernel code makes heavy use of dynamic (heap) allocation, and many code modules within the kernel provide their own abstractions for customized memory management. on the other hand, the kernel code involves highly complicated data flow, so it is hard to determine where an object is supposed to be released. given the complex and critical nature of os kernels, as well as the heavy specialization, existing methods largely fail at effectively and thoroughly detecting kernel memory leaks. \nin this paper, we present k-meld, a static detection system for kernel memory leaks. k-meld features multiple new techniques that can automatically identify specialized allocation/deallocation functions and determine the expected memory-release locations. specifically, we first develop a usage- and structure-aware approach to effectively identify specialized allocation functions, and employ a new rule-mining approach to identify the corresponding deallocation functions. we then develop a new ownership reasoning mechanism that employs enhanced escape analysis and consumer-function analysis to infer expected release locations. by applying k-meld to the linux kernel, we confirm its effectiveness: it finds  218  new bugs,  with  41  cves assigned. out of those  218  bugs,  115  are in specialized modules.", "differential training: a generic framework to reduce label noises for android malware detection": "a common problem in machine learning-based malware detection is that training data may contain noisy labels and it is challenging to make the training data noise-free at a large scale. to address this problem, we propose a generic framework to reduce the noise level of training data for the training of any machine learning-based android malware detection. our framework makes use of all intermediate states of two identical deep learning classification models during their training with a given noisy training dataset and generate a noise-detection feature vector for each input sample. our framework then applies a set of outlier detection algorithms on all noise-detection feature vectors to reduce the noise level of the given training data before feeding it to any machine learning based android malware detection approach. in our experiments with three different android malware detection approaches, our framework can detect significant portions of wrong labels in different training datasets at different noise ratios, and improve the performance of android malware detection approaches.", "does every second count? time-based evolution of malware behavior in sandboxes": "the amount of time in which a sample is executed is one of the key parameters of a malware analysis sandbox. setting the threshold too high hinders the scalability and reduces the number of samples that can be analyzed in a day; too low and the samples may not have the time to show their malicious behavior, thus reducing the amount and quality of the collected data. therefore, an analyst needs to find the \u2018sweet spot\u2019 that allows to collect only the minimum amount of information required to properly classify each sample. anything more is wasting resources, anything less is jeopardizing the experiments. \ndespite its importance, there are no clear guidelines on how to choose this parameter, nor experiments that can help companies to assess the pros and cons of a choice over another. to fill this gap, in this paper we provide the first large-scale study of the impact that the execution time has on both the amount and the quality of the collected events. we measure the evolution of system calls and code coverage, to draw a precise picture of the fraction of runtime behavior we can expect to observe in a sandbox. finally, we implemented a machine learning based malware detection method, and applied it to the data collected in different time windows, to also report on the relevance of the events observed at different points in time. \nour results show that most samples run for either less than two minutes or for more than ten. however, most of the behavior (and 98% of the executed basic blocks) are observed during the first two minutes of execution, which is also the time windows that result in a higher accuracy of our ml classifier. we believe this information can help future researchers and industrial sandboxes to better tune their analysis systems.", "eararray: defending against dolphinattack via acoustic attenuation": "dolphinattacks (i.e., inaudible voice commands) modulate audible voices over ultrasounds to inject malicious commands silently into voice assistants and manipulate controlled systems (e.g., doors or smart speakers). eliminating dolphinattacks is challenging if ever possible since it requires to modify the microphone hardware. in this paper, we design eararray, a lightweight method that can not only detect such attacks but also identify the direction of attackers without requiring any extra hardware or hardware modification. essentially, inaudible voice commands are modulated on ultrasounds that inherently attenuate faster than the one of audible sounds. by inspecting the command sound signals via the built-in multiple microphones on smart devices, eararray is able to estimate the attenuation rate and thus detect the attacks. we propose a model of the propagation of audible sounds and ultrasounds from the sound source to a voice assistant, e.g., a smart speaker, and illustrate the underlying principle and its feasibility. we implemented eararray using two specially-designed microphone arrays and our experiments show that eararray can detect inaudible voice commands with an accuracy of 99% and recognize the direction of the attackers with an accuracy of 97.89%.", "emilia: catching iago in legacy code": "there has been interest in mechanisms that enable the secure use of legacy code to implement trusted code in a trusted execution environment (tee), such as intel sgx. however, because legacy code generally assumes the presence of an operating system, this naturally raises the spectre of iago attacks on the legacy code. we observe that not all legacy code is vulnerable to iago attacks and that legacy code must use return values from system calls in an unsafe way to have iago vulnerabilities.\nbased on this observation, we develop emilia, which automatically detects iago vulnerabilities in legacy applications by fuzzing applications using system call return values. we use emilia to discover 51 iago vulnerabilities in 17 applications, and find that iago vulnerabilities are widespread and common. we conduct an in-depth analysis of the vulnerabilities we found and conclude that while common, the majority (82.4%) can be mitigated with simple, stateless checks in the system call forwarding layer, while the rest are best fixed by finding and patching them in the legacy code. finally, we study and evaluate different trade-offs in the design of emilia.", "fare: enabling fine-grained attack categorization under low-quality labeled data": "supervised machine learning classifiers have been widely used for attack detection, but their training requires abundant high-quality labels. unfortunately, high-quality labels are difficult to obtain in practice due to the high cost of data labeling and the constant evolution of attackers. without such labels, it is challenging to train and deploy targeted countermeasures.\nin this paper, we propose fare, a clustering method to enable fine-grained attack categorization under low-quality labels. we focus on two common issues in data labels: 1) missing labels for certain attack classes or families; and 2) only having coarse-grained labels available for different attack types. the core idea of fare is to take full advantage of the limited labels while using the underlying data distribution to consolidate the low-quality labels. we design an ensemble model to fuse the results of multiple unsupervised learning algorithms with the given labels to mitigate the negative impact of missing classes and coarse-grained labels. we then train an input transformation network to map the input data into a low-dimensional latent space for fine-grained clustering. using two security datasets (android malware and network intrusion traces), we show that fare significantly outperforms the state-of-the-art (semi-)supervised learning methods in clustering quality/correctness. further, we perform an initial deployment of fare by working with a large e-commerce service to detect fraudulent accounts. with real-world a/b tests and manual investigation, we demonstrate the effectiveness of fare to catch previously-unseen frauds.", "favocado: fuzzing the binding code of javascript engines using semantically correct test cases": "javascript runtime systems include some specialized programming interfaces, called binding layers. binding layers translate data representations between javascript and unsafe low-level languages, such as c and c++, by converting data between different types. due to the wide adoption of javascript (and javascript engines) in the entire computing ecosystem, discovering bugs in javascript binding layers is critical. nonetheless, existing javascript fuzzers cannot adequately fuzz binding layers due to two major challenges: generating syntactically and semantically correct test cases, and reducing the size of the input space for fuzzing.\nin this paper, we propose favocado, a novel fuzzing approach that focuses on fuzzing binding layers of javascript runtime systems. favocado can generate syntactically and semantically correct javascript test cases through the use of extracted semantic information and careful maintaining of execution states. this way, test cases that favocado generates do not raise unintended runtime exceptions, which substantially increases the chance of triggering binding code. additionally, exploiting a unique feature (relative isolation) of binding layers, favocado significantly reduces the size of the fuzzing input space by splitting dom objects into equivalence classes and focusing fuzzing within each equivalence class. \nwe demonstrate the effectiveness of favocado in our experiments and show that favocado outperforms another state-of-the-art dom fuzzer and discovers six times more bugs. finally, during the evaluation, we find 61 previously unknown bugs in four javascript runtime systems (adobe acrobat reader, foxit pdf reader, chromium, and webkit). 33 of these bugs are security vulnerabilities.", "flowlens: enabling efficient flow classification for ml-based network security applications": "an emerging trend in network security consists in the adoption of programmable switches for performing various security tasks in large-scale, high-speed networks. however, since existing solutions are tailored to specific tasks, they cannot accommodate a growing variety of ml-based security applications, i.e., security-focused tasks that perform targeted flow classification based on packet size or inter-packet frequency distributions with the help of supervised machine learning algorithms. we present flowlens, a system that leverages programmable switches to efficiently support multi-purpose ml-based security applications. flowlens collects features of packet distributions at line speed and classifies flows directly on the switches, enabling network operators to re-purpose this measurement primitive at run-time to serve a different flow classification task. to cope with the resource constraints of programmable switches, flowlens computes for each flow a memory-efficient representation of relevant features, named ``flow marker''. despite its small size, a flow marker contains enough information to perform accurate flow classification. since flow markers are highly customizable and application-dependent, flowlens can automatically parameterize the flow marker generation guided by a multi-objective optimization process that can balance their size and accuracy. we evaluated our system in three usage scenarios: covert channel detection, website fingerprinting, and botnet chatter detection. we find that very small markers enable flowlens to achieve a 150 fold increase in monitoring capacity for covert channel detection with an accuracy drop of only 3% when compared to collecting full packet distributions.", "fltrust: byzantine-robust federated learning via trust bootstrapping": "byzantine-robust federated learning aims to enable a service provider to learn an accurate global model when a bounded number of clients are malicious.  the key idea of existing byzantine-robust federated learning methods is that the service provider performs statistical analysis among the  clients' local model updates and removes suspicious ones, before aggregating them to update the global model. however, malicious clients can still corrupt the global models in these methods via sending carefully crafted local model updates to the service provider. the fundamental reason is that there is no root of trust in existing federated learning methods, i.e., from the service provider's perspective, every client could be malicious. \nin this work, we bridge the gap via proposing emph{fltrust}, a new federated learning method in which the service provider itself bootstraps trust. in particular, the service provider itself collects a clean small training dataset (called emph{root dataset}) for the learning task and the service provider maintains a model (called emph{server model}) based on it to bootstrap trust. in each iteration, the service provider first assigns a trust score to each local model update from the clients, where a local model update has a lower trust score if its direction deviates more from the direction of the server model update. then, the service provider normalizes the magnitudes of the local model updates such that they lie in the same hyper-sphere as the server model update in the vector space. our normalization limits the impact of malicious local model updates with large magnitudes. finally, the service provider computes the average of the normalized local model updates weighted by their trust scores as a global model update, which is used to update the global model.  our extensive evaluations on six datasets from different domains show that our fltrust is secure against both existing attacks and strong adaptive attacks. for instance, using a root dataset with less than 100 examples, fltrust under adaptive attacks with 40%-60% of malicious clients can still train global models that are as accurate as the global models trained by fedavg under no attacks, where fedavg is a popular method in non-adversarial settings.", "from library portability to para-rehosting: natively executing microcontroller software on commodity hardware": "finding bugs in microcontroller (mcu) firmware is challenging, even for device manufacturers who own the source code. the mcu runs different instruction sets than x86 and exposes a very different development environment. this invalidates many existing sophisticated software testing tools on x86. to maintain a unified developing and testing environment, a straightforward way is to re-compile the source code into the native executable for a commodity machine (called rehosting). however, ad-hoc re-hosting is a daunting and tedious task and subject to many issues (library-dependence, kernel-dependence and hardware-dependence). in this work, we systematically explore the portability problem of mcu software and propose para-rehosting to ease the porting process. specifically, we abstract and implement a portable mcu (pmcu) using the posix interface. it models common functions of the mcu cores. for peripheral specific logic, we propose hal-based peripheral function replacement, in which high-level hardware functions are replaced with an equivalent backend driver on the host. these backend drivers are invoked by well-designed para-apis and can be reused across many mcu oss. we categorize common hal functions into four types and implement templates for quick backend development. using the proposed approach, we have successfully rehosted nine mcu oss including the widely deployed amazon freertos, arm mbed os, zephyr and liteos. to demonstrate the superiority of our approach in terms of security testing, we used off-the-shelf dynamic analysis tools (afl and asan) against the rehosted programs and discovered 28 previously-unknown bugs, among which 5 were confirmed by cve and the other 19 were confirmed by vendors at the time of writing.", "gala: greedy computation for linear algebra in privacy-preserved neural networks": "machine learning as a service (mlaas) is enabling a wide range of smart applications on end devices. however, privacy still remains a fundamental challenge. the schemes that exploit homomorphic encryption (he)-based linear computations and garbled circuit (gc)-based nonlinear computations have demonstrated superior performance to enable privacy-preserved mlaas. nevertheless, there is still a significant gap in the computation speed. our investigation has found that the he-based linear computation dominates the total computation time for state-of-the-art deep neural networks. furthermore, the most time-consuming component of the he-based linear computation is a series of permutation (perm) operations that are imperative for dot product and convolution in privacy-preserved mlaas. this work focuses on a deep optimization of the he-based linear computations to minimize the perm operations, thus substantially reducing the overall computation time. to this end, we propose gala: greedy computation for linear algebra in privacy-preserved neural networks, which views the he-based linear computation as a series of homomorphic add, mult and perm operations and chooses the least expensive operation in each linear computation step to reduce the overall cost. gala makes the following contributions: (1) it introduces a row-wise weight matrix encoding and combines the share generation that is needed for the gc-based nonlinear computation, to reduce the perm operations for the dot product; (2) it designs a firstadd-second-perm approach (named kernel grouping) to reduce perm operations for convolution. as such, gala efficiently reduces the cost for the he-based linear computation, which is a critical building block in almost all of the recent frameworks for privacy-preserved neural networks, including gazelle (usenix security\u201918), delphi (usenix security\u201920), and cryptflow2 (ccs\u201920). with its deep optimization of the he-based linear computation, gala can be a plug-and-play module integrated into these systems to further boost their efficiency. our experiments show that it achieves a significant speedup up to 700\u00d7 for the dot product and 14\u00d7 for the convolution computation under different data dimensions. meanwhile, gala demonstrates an encouraging runtime boost by 2.5\u00d7, 2.7\u00d7, 3.2\u00d7, 8.3\u00d7, 7.7\u00d7, and 7.5\u00d7 over gazelle and 6.5\u00d7, 6\u00d7, 5.7\u00d7, 4.5\u00d7, 4.2\u00d7, and 4.1\u00d7 over cryptflow2, on alexnet, vgg, resnet-18, resnet-50, resnet-101, and resnet-152, respectively.", "hera: hotpatching of embedded real-time applications": "memory corruption attacks are a pre-dominant attack vector against iot devices. simply updating vulnerable iot software is not always possible due to unacceptable downtime and a required reboot. these side-effects must be avoided for highly-available embedded systems such as medical devices and, generally speaking, for any embedded system with real-time constraints.\nto avoid downtime and reboot of a system, previous research has introduced the concept of hotpatching. however, the existing approaches cannot be applied to resource-constrained iot devices. furthermore, possible hardware-related issues have not been addressed, i.e., the inability to directly modify the firmware image due to read-only memory.\nin this paper, we present the design and implementation of hera (hotpatching of embedded real-time applications) which utilizes hardware-based built-in features of commodity cortex-m microcontrollers to perform hotpatching of embedded systems. hera preserves hard real-time constraints while keeping the additional resource usage to a minimum. in a case study, we apply hera to two vulnerable medical devices. furthermore, we leverage hera to patch an existing vulnerability in the freertos operating system. these applications demonstrate the high practicality and efficiency of our approach.", "hunting the haunter \u2014 efficient relational symbolic execution for spectre with haunted relse": "spectre are microarchitectural attacks which were made public in january 2018. they allow an attacker to recover secrets by exploiting speculations. detection of spectre is particularly important for cryptographic libraries and defenses at the software level have been proposed. yet, defenses correctness and spectre detection pose challenges due on one hand to the explosion of the exploration space induced by speculative paths, and on the other hand to the introduction of new spectre vulnerabilities at different compilation stages. we propose an optimization, coined haunted relse, that allows scalable detection of spectre vulnerabilities at binary level. we prove the optimization semantically correct w.r.t. the more naive explicit speculative exploration approach used in state-of-the-art tools. we implement haunted relse in a symbolic analysis tool, and extensively test it on a well-known litmus testset for spectre-pht, and on a new litmus testset for spectre-stl, which we propose. our technique finds more violations and scales better than state-of-the-art techniques and tools, analyzing real-world cryptographic libraries and finding new violations. thanks to our tool, we discover that index-masking, a standard defense for spectre-pht, and well-known gcc options to compile position independent executables introduce spectre-stl violations. we propose and verify a correction to index-masking to avoid the problem.", "improving signal's sealed sender": "the signal messaging service recently deployed a emph{sealed sender} feature that provides sender anonymity by cryptographically hiding a message's sender from the service provider. we demonstrate, both theoretically and empirically, that this one-sided anonymity is broken when two parties send multiple messages back and forth; that is, the promise of sealed sender does not emph{compose} over a conversation of messages. our attack is in the family of statistical disclosure attacks (sdas), and is made particularly effective by emph{delivery receipts} that inform the sender that a message has been successfully delivered, which are enabled by default on signal. we show using theoretical and simulation-based models that signal could link sealed sender users in as few as 5 messages.\nour attack goes beyond tracking users via network-level identifiers by working at the application layer of signal. this make our attacks particularly effective against users that employ tor or vpns as anonymity protections, who would otherwise be secure against network tracing. we present a range of practical mitigation strategies that could be employed to prevent such attacks, and we prove our protocols secure using a new simulation-based security definition for one-sided anonymity over any sequence of messages. the simplest provably-secure solution uses many of the same mechanisms already employed by the (flawed) sealed-sender protocol used by signal, which means it could be deployed with relatively small overhead costs; we estimate that the extra cryptographic cost of running our most sophisticated solution in a system with millions of users would be less than $40 per month.", "iotsafe: enforcing safety and security policy with real iot physical interaction discovery": "the internet of things (iot) platforms bring significant convenience for increased home automation. especially, these platforms provide many new features for managing multiple iot devices to control their physical surroundings. however, these features also bring new safety and security challenges. for example, an attacker can manipulate iot devices to launch attacks through unexpected physical interactions. unfortunately, very few existing research investigates the physical interactions among iot devices and their impacts on iot safety and security. in this paper, we propose a novel dynamic safety and security policy enforcement system called iotsafe, which can capture and manage real physical interactions considering contextual features on smart home platforms. to identify real physical interactions of iot devices, we present a runtime physical interaction discovery approach, which employs both static analysis and dynamic testing techniques to identify runtime physical interactions among iot devices.  in addition, iotsafe generates physical and non-physical interaction paths and their context in a multi-app environment. based on paths and context data, iotsafe constructs physical models for temporal physical interactions, which can predict incoming risky situations and block unsafe device states accordingly. we implement a prototype of iotsafe on the smartthings platform. our extensive evaluations demonstrate that iotsafe effectively identifies 39 real physical interactions among 130 potential interactions in our experimental environment.  iotsafe also successfully predicts risky situations related to temporal physical interactions with nearly 96% accuracy and prevents highly risky conditions.", "kubo: precise and scalable detection of user-triggerable undefined behavior bugs in os kernel": "undefined behavior bugs (ub) often refer to a wide range of programming errors that mainly reside in software implemented in relatively low-level programming languages e.g., c/c++. os kernels are particularly plagued by ub due to their close interactions with the hardware. a triggered ub can often lead to exploitation from unprivileged userspace programs and cause critical security and reliability issues inside the os. the previous works on detecting ub in kernels had to sacrifice precision for scalability, and in turn, suffered from extremely high false positives which severely impaired their usability.\nwe propose a novel static ub detector for linux kernel, called kubo which simultaneously achieves high precision and whole-kernel scalability. kubo is focused on detecting critical ub that can be triggered by userspace input. the high precision comes from kubo\u2019s verification of the satisfiability of the ub-triggering paths and conditions. the whole-kernel scalability is enabled by an efficient inter-procedural analysis, which incrementally walks backward along callchains in an on-demand manner. we evaluate kubo on several versions of whole linux kernels (including drivers). kubo found 23 critical ubs that were previously unknown in the latest linux kernel. kubo\u2019s false detection rate is merely 27.5%, which is significantly lower than that of the state-of-the-art kernel ub detectors (91%). our evaluation also shows the bug reports generated by kubo are easy to triage.", "laksa: a probabilistic proof-of-stake protocol": "we present large-scale known-committee stake-based agreement (laksa), a chain-based proof-of-stake protocol that is dedicated, but not limited, to cryptocurrencies. laksa minimizes interactions between nodes through lightweight committee voting, resulting in a simpler, more robust, and more scalable proposal than competing systems. it also mitigates other drawbacks of previous systems, such as high reward variance and long confirmation times. laksa can support large numbers of nodes by design, and provides probabilistic safety guarantees in which a client makes commit decisions by calculating the probability that a transaction is reverted based on its blockchain view. we present a thorough analysis of laksa and report on its implementation and evaluation. furthermore, our new technique of proving safety can be applied more broadly to other proof-of-stake protocols.", "manipulating the byzantine: optimizing model poisoning attacks and defenses for federated learning": "federated learning (fl) enables many data owners (e.g., mobile devices) to train a joint ml model (e.g., a next-word prediction classifier) without the need of sharing their private training data. \nhowever, fl is known to be susceptible to  poisoning attacks by malicious participants (e.g., adversary-owned mobile devices) who aim at hampering the accuracy of the jointly trained model through sending malicious inputs during the federated training process. \nin this paper, we present a generic framework for model poisoning attacks on fl. we show that our framework leads to  poisoning attacks that substantially outperform state-of-the-art model poisoning attacks by large margins. for instance, our attacks result in $1.5times$ to $60times$ higher reductions in the accuracy of fl models compared to previously discovered poisoning attacks. \nour work demonstrates that existing byzantine-robust fl algorithms are significantly more susceptible  to model poisoning than previously thought. motivated by this, we design a defense against fl poisoning, called emph{divide-and-conquer} (dnc). we demonstrate that dnc outperforms all existing byzantine-robust fl algorithms in defeating model poisoning attacks,\nspecifically,  it is $2.5times$ to $12times$ more resilient in our experiments with different datasets and models.", "minos: a lightweight real-time cryptojacking detection system": "emerging webassembly(wasm)-based cryptojacking malware covertly uses the computational resources of users without their consent or knowledge. indeed, most victims of this malware are unaware of such unauthorized use of their computing power due to techniques employed by cryptojacking malware authors such as cpu throttling and obfuscation. a number of dynamic analysis-based detection mechanisms exist that aim to circumvent such techniques. however, since these mechanisms use dynamic features, the collection of such features, as well as the actual detection of the malware, require that the cryptojacking malware run for a certain amount of time, effectively mining for that period, and therefore causing significant overhead. to solve these limitations, in this paper, we propose minos, a novel, extremely lightweight cryptojacking detection system that uses deep learning techniques to accurately detect the presence of unwarranted wasm-based mining activity in real-time. minos  uses an image-based classification technique to distinguish between benign webpages and those using wasm to implement unauthorized mining. specifically, the classifier implements a convolutional neural network (cnn) model trained with a comprehensive dataset of current malicious and benign wasm binaries. minos achieves exceptional accuracy with a low tnr and fpr. moreover, our extensive performance analysis of minos shows that the proposed detection technique can detect mining activity instantaneously from the most current in-the-wild cryptojacking malware with an accuracy of 98.97%, in an average of 25.9 milliseconds while using a maximum of 4% of the cpu and 6.5% of ram, proving that minos is highly effective while lightweight, fast, and computationally inexpensive.", "mondrian: comprehensive inter-domain network zoning architecture": "a central element of designing it security infrastructures is the logical segmentation of information assets into groups sharing the same security requirements and policies, called network zones. as more business ecosystems are migrated to the cloud, additional demands for cybersecurity emerge and make the network-zone operation and management for large corporate networks challenging. in this paper, we introduce the new concept of an inter-domain transit zone that securely bridges physically and logically non-adjacent zones in large-scale information systems, simplifying complex network-zone structures. with inter-zone translation points, we also ensure communication integrity and confidentiality while providing lightweight security-policy enforcement. a logically centralized network coordinator enables scalable and flexible network management. our implementation demonstrates that the new architecture merely introduces a few microseconds of additional processing delay in transit.", "netplier: probabilistic network protocol reverse engineering from message traces": "network protocol reverse engineering is an important challenge with many security applications. a popular kind of method leverages network message traces. these methods rely on pair-wise sequence alignment and/or tokenization. they have various limitations such as difficulties of handling a large number of messages and dealing with inherent uncertainty. in this paper, we propose a novel probabilistic method for network trace based protocol reverse engineering. it first makes use of multiple sequence alignment to align all messages and then reduces the problem to identifying the keyword field from the set of aligned fields. the keyword field determines the type of a message. the identification is probabilistic, using random variables to indicate the likelihood of each field (being the true keyword). a joint distribution is constructed among the random variables and the observations of the messages. probabilistic inference is then performed to determine the most likely keyword field, which allows messages to be properly clustered by their true types and enables the recovery of message format and state machine. our evaluation on 10 protocols shows that our technique substantially outperforms the state-of-the-art and our case studies show the unique advantages of our technique in iot protocol reverse engineering and malware analysis.", "oblivsketch: oblivious network measurement as a cloud service": "network function virtualisation enables versatile network functions as cloud services with reduced cost. specifically, network measurement tasks such as heavy-hitter detection and flow distribution estimation serve many core network functions for improved performance and security of enterprise networks. however, deploying network measurement services in third-party multi-tenant cloud service providers raises critical privacy and security concerns. recent studies demonstrate that leaking and abusing flow statistics can lead to severe network attacks such as ddos, network topology manipulation and poisoning, etc.\nin this paper, we propose oblivsketch, an oblivious network measurement service using intel sgx. it employs hardware enclave for secure network statistics generation and queries. the statistics are maintained in newly designed oblivious data structures inside the sgx enclave and queried by data-oblivious algorithms to prevent data leakage caused by access patterns to the memory of sgx. to demonstrate the practicality, we implement oblivsketch as a full-fledge service integrated with the off-the-shelf sdn framework. the evaluations demonstrate that oblivsketch consumes a constant and small memory space (6mb) to track a massive amount of flows (from 30k to 1.45m), and it takes no more than 15ms to respond six widely adopted measurement queries for a 5s-trace with 70k flows.", "on the insecurity of sms one-time password messages against local attackers in modern mobile devices": "sms messages containing one-time passwords (otps) are a widely used mechanism for performing authentication in mobile applications. in fact, many popular apps use otps received via sms as the only authentication factor, entirely replacing password-based authentication schemes. although sms otp authentication mechanisms provide significant convenience to end-users, they also have significant security implications. in this paper, we study these mobile apps' authentication schemes based on sms otps, and, in particular, we perform a systematic study on the threats posed by ``local attacks,'' a scenario in which an attacker has control over an unprivileged third-party app on the victim's device.\nthis study was carried out using a combination of reverse engineering, formal verification, user studies, and large-scale automated analysis. our work not only revealed vulnerabilities in third-party apps, but it also uncovered several new design and implementation flaws in core apis implemented by the mobile operating systems themselves. for instance, we found two official android apis to be vulnerable by design, i.e., apis that inevitably lead to the implementation of insecure authentication schemes, even when used according to their documentation. moreover, we found that other apis are prone to be used unsafely by apps' developers.\nour large-scale study found 36 apps, sharing hundreds of millions of installations, that misuse these apis, allowing a malicious local attacker to completely hijack their accounts. such vulnerable apps include telegram and kakaotalk, some of the most popular messaging apps worldwide. finally, we proposed a new and safer mechanism to perform sms-based authentication, and we prove its safety using formal verification.", "pfirewall: semantics-aware customizable data flow control for smart home privacy protection": "internet of things (iot) platforms enable users to deploy home automation applications. meanwhile, privacy issues arise as large amounts of sensitive device data flow out to iot platforms. most of the data flowing out to a platform actually do not trigger automation actions, while homeowners currently have no control once devices are bound to the platform. we present pfirewall, a customizable data-flow control system to enhance the privacy of iot platform users. pfirewall automatically generates data-minimization policies, which only disclose minimum amount of data to fulfill automation. in addition, pfirewall provides interfaces for homeowners to customize individual privacy preferences by defining user-specified policies. to enforce these policies, pfirewall transparently intervenes and mediates the communication between iot devices and the platform, without modifying the platform, iot devices, or hub. evaluation results on four real-world testbeds show that pfirewall reduces iot data sent to the platform by 97% without impairing home automation, and effectively mitigates user-activity inference/tracking attacks and other privacy risks.", "pgfuzz: policy-guided fuzzing for robotic vehicles": "robotic vehicles (rvs) are becoming essential tools of modern systems, including autonomous delivery services, public transportation, and environment monitoring. despite their diverse deployment, safety and security issues with rvs limit their wide adoption. most attempts to date in rv security aim to propose defenses that harden their control program against syntactic bugs, input validation bugs, and external sensor spoofing attacks. in this paper, we introduce pgfuzz, a policy-guided fuzzing framework, which validates whether an rv adheres to identified safety and functional policies that cover user commands, configuration parameters, and physical states. pgfuzz expresses desired policies through temporal logic formulas with time constraints as a guide to fuzz the analyzed system. specifically, it generates fuzzing inputs that minimize a distance metric measuring ``how close'' the rv current state is to a policy violation. in addition, it uses static and dynamic analysis to focus the fuzzing effort only on those commands, parameters, and environmental factors that influence the ``truth value'' of any of the exercised policies. the combination of these two techniques allows pgfuzz to increase the efficiency of the fuzzing process significantly. we validate pgfuzz on three rv control programs, ardupilot, px4, and paparazzi, with 56 unique policies. pgfuzz discovered 156 previously unknown bugs, 106 of which have been acknowledged by their developers.", "phantomcache: obfuscating cache conflicts with localized randomization": "cache conflicts due to deterministic memory-to-cache mapping have long been exploited to leak sensitive information such as secret keys. while randomized mapping is fully investigated for l1 caches, it still remains unresolved about how to secure a much larger last-level cache (llc). recent solutions periodically change the mapping strategy to disrupt the crafting of conflicted addresses, which is a critical attack procedure to exploit cache conflicts. remapping, however, increases both miss rate and access latency. we present phantomcache for securing an llc with remapping-free randomized mapping. we propose a localized randomization technique to bound randomized mapping of a memory address within only a limited number of cache sets. the small randomization space offers fast set search over an llc in a memory access. the intrinsic randomness still suffices to obfuscate conflicts and disrupt efficient exploitation of conflicted addresses. we evaluate phantomcache against an attacker exploring the state-of-the-art attack with linear-complexity. to secure an 8-bank 16~mb 16-way llc, phantomcache confines randomization space of an address within 8 sets and brings only 0.5% performance degradation and 0.5% storage overhead per cache line, which are 3x and 9x more efficient than the state-of-the-art solutions. moreover, phantomcache is solely an architectural solution and requires no software change.", "phoenix: device-centric cellular network protocol monitoring using runtime verification": "end-user-devices in the current cellular ecosystem are prone to many different vulnerabilities across different generations and protocol layers. fixing these vulnerabilities retrospectively can be expensive, challenging, or just infeasible. a pragmatic approach for dealing with such a diverse set of vulnerabilities would be to identify attack attempts at runtime on the device side, and thwart them with mitigating and corrective actions. towards this goal, in the paper we propose a general and extendable approach called phoenix for identifying n-day cellular network control-plane vulnerabilities as well as dangerous practices of network operators from the device vantage point. phoenix monitors the device-side cellular network traffic for performing signature-based unexpected behavior detection through lightweight runtime verification techniques. signatures in phoenix can be manually-crafted by a cellular network security expert or can be automatically synthesized using an optional component of phoenix , which reduces the signature synthesis problem to the language learning from the informant problem. based on the corrective actions that are available to phoenix when an undesired behavior is detected, different instantiations of phoenix are possible: a full-fledged defense when deployed inside a baseband processor; a user warning system when deployed as a mobile application; a probe for identifying attacks in the wild. one such instantiation of phoenix was able to identify all 15 representative n-day vulnerabilities and unsafe practices of 4g lte networks considered in our evaluation with a high packet processing speed (\u223c68000 packets/second) while inducing only a moderate amount of energy overhead (\u223c4mw).", "poseidon: privacy-preserving federated neural network learning": "in this paper, we address the problem of privacy-preserving training and evaluation of neural networks in an $n$-party, federated learning setting. we propose a novel system, poseidon, the first of its kind in the regime of privacy-preserving neural network training. it employs multiparty lattice-based cryptography to preserve the confidentiality of the training data, the model, and the evaluation data, under a passive-adversary model and collusions between up to $n-1$ parties. to efficiently execute the secure backpropagation algorithm for training neural networks, we provide a generic packing approach that enables single instruction, multiple data (simd) operations on encrypted data. we also introduce arbitrary linear transformations within the cryptographic bootstrapping operation, optimizing the costly cryptographic computations over the parties, and we define a constrained optimization problem for choosing the cryptographic parameters. our experimental results show that poseidon achieves accuracy similar to centralized or decentralized non-private approaches and that its computation and communication overhead scales linearly with the number of parties. poseidon trains a 3-layer neural network on the mnist dataset with 784 features and 60k samples distributed among 10 parties in less than 2 hours.", "practical blind membership inference attack via differential comparisons": "membership inference (mi) attacks affect user privacy by inferring whether given data samples have been used to train a target learning model, e.g., a deep neural network. there are two types of mi attacks in the literature, i.e., these with and without shadow models. the success of the former heavily depends on the quality of the shadow model, i.e., the transferability between the shadow and the target; the latter, given only blackbox probing access to the target model, cannot make an effective inference of unknowns, compared with mi attacks using shadow models, due to the insufficient number of qualified samples labeled with ground truth membership information.\nin this paper, we propose an mi attack, called blindmi, which probes the target model and extracts membership semantics via a novel approach, called differential comparison. the high-level idea is that blindmi first generates a dataset with nonmembers via transforming existing samples into new samples, and then differentially moves samples from a target dataset to the generated, non-member set in an iterative manner. if the differential move of a sample increases the set distance, blindmi considers the sample as non-member and vice versa.\nblindmi was evaluated by comparing it with state-of-the-art mi attack algorithms. our evaluation shows that blindmi improves f1-score by nearly 20% when compared to state-of-the-art on some datasets, such as purchase-50 and birds-200, in the blind setting where the adversary does not know the target model\u2019s architecture and the target dataset\u2019s ground truth labels. we also show that blindmi can defeat state-of-the-art defenses.", "practical non-interactive searchable encryption with forward and backward privacy": "in dynamic symmetric searchable encryption (dsse), forward privacy ensures that previous search queries cannot be associated with future updates, while backward privacy guarantees that subsequent search queries cannot be associated with deleted documents in the past. in this work, we propose a generic forward and backward-private dsse scheme, which is, to the best of our knowledge, the first practical and non-interactive type-ii backward-private dsse scheme not relying on trusted execution environments. to this end, we first introduce a new cryptographic primitive, named symmetric revocable encryption (sre), and propose a modular construction from some succinct cryptographic primitives. then we present our dsse scheme based on the proposed sre, and instantiate it with lightweight symmetric primitives. at last, we implement our scheme and\ncompare it with the most efficient type-ii backward-private scheme to date (demertzis et al., ndss 2020). in a typical network environment, our result shows that the search in our scheme outperforms it by 2-11x under the same security notion.", "preventing and detecting state inference attacks on android": "in the realm of the android ecosystem, one relevant threat is posed by phishing attacks. phishing attacks are particularly problematic for mobile platforms because they do not provide enough information for a user to reliably distinguish a legitimate app from a malicious app spoofing the ui of the legitimate one. a key factor that determines the success rate of a phishing attack is proper timing: the user is more prone to provide sensitive data (such as her passwords) if the malicious spoofed ui appears when the victim expects to interact with the target app. on android, malware determines the right timing by mounting so-called state inference attacks, which can be used, for example, to infer the exact moment that the user started a target app and thus expects to interact with it. even though android app sandbox is designed to prevent these attacks, they are still possible by abusing vulnerable apis that leak such sensitive information: the usual scenario is a malicious app that \"polls\" these vulnerable apis, infers when a target app is about to be used by the user, and makes the spoofed ui appear on top of the screen at the right time. all previous bugs of this kind have been fixed in the latest version of android. \nthis paper presents two main research contributions related to preventing and detecting state inference attacks. first, we discuss the design and implementation of a new vulnerability detection system, which specifically aims at identifying new vulnerabilities that can be used to mount state inference attacks. our approach relies on both static and dynamic analysis techniques and it identified 18 previously unknown bugs (leading to 6 cve) in the latest versions of android. \nsecond, we present a new on-device analysis system able to detect exploitation attempts of vulnerable resources and apis. this system is based on the key hypothesis that mere \"polling behaviors\" can be used as a strong signal of a potential attack, independently of other factors (that previous works rely on). we performed an empirical analysis over a corpus of benign and malicious apps, and we find that this hypothesis is indeed correct. this approach has the advantage of being able to detect exploitation attempts even when the abused api is not known to be vulnerable in advance. we implemented this system as an android framework modification, and we show it incurs a negligible overhead.", "privacyflash pro: automating privacy policy generation for mobile apps": "various privacy laws require mobile apps to have privacy policies. questionnaire-based policy generators are intended to help developers with the task of policy creation. however, generated policies depend on the generators' designs as well as developers' abilities to correctly answer privacy questions on their apps. in this study we show that policies generated with popular policy generators are often not reflective of apps' privacy practices. we believe that policy generation can be improved by supplementing the questionnaire-based approach with code analysis. we design and implement privacyflash pro, a privacy policy generator for ios apps that leverages static analysis. privacyflash pro identifies code signatures --- composed of plist permission strings, framework imports, class instantiations, authorization methods, and other evidence --- that are mapped to privacy practices expressed in privacy policies. resources from package managers are used to identify libraries.\nwe tested privacyflash pro in a usability study with 40 ios app developers and received promising results both in terms of reliably identifying apps' privacy practices as well as on its usability. we measured an f-1 score of 0.95 for identifying permission uses. 24 of 40 developers rated privacyflash pro with at least 9 points on a scale of 0 to 10 for a net promoter score of 42.5. the mean system usability score of 83.4 is close to excellent. we provide privacyflash pro as an open source project to the ios developer community. in principle, our approach is platform-agnostic and adaptable to the android and web platforms as well. to increase privacy transparency and reduce compliance issues we make the case for privacy policies as software development artifacts. privacy policy creation should become a native extension of the software development process and adhere to the mental model of software developers.", "qpep: an actionable approach to secure and performant broadband from geostationary orbit": "satellite broadband services are critical infrastructures, bringing connectivity to the most remote regions of the globe. however, due to performance concerns, many geostationary satellite broadband services are unencrypted by default and vulnerable to long-range eavesdropping attacks. the result is that deeply sensitive internet traffic is regularly broadcast in clear-text over vast coverage areas.\nthis paper delves into the underlying causes of this insecure network design, presenting the case that physical characteristics effecting tcp performance and the widespread use of performance enhancing proxies (peps) have created the perception of a security/performance trade-off in these networks. a review of previous mitigation attempts finds limited real-world adoption due to a variety of factors ranging from misaligned commercial incentives to the prevalence of unverified ``black-box'' encryption products.\nto address these shortcomings, we design and implement a fully open-source and encrypted-by-default pep/vpn hybrid, call qpep. built around the quic standard, qpep enables individuals to encrypt satellite traffic without isp involvement. additionally, we present an open and replicable docker-based testbed for benchmarking satellite peps like qpep through simulation. these experiments show that qpep enables satellite customers to encrypt their tcp traffic with up to 65% faster page load times (plts) compared to traditional vpn encryption. even relative to unencrypted peps, qpep offers up to 45% faster plts while adding over-the-air security. we briefly evaluate additional tweaks to quic which may further optimize qpep performance. together, these assessments suggest that qpep represents a promising new technique for bringing both security and performance to high-latency satellite broadband without requiring alterations to status-quo network implementations.", "randrunner: distributed randomness from trapdoor vdfs with strong uniqueness": "generating randomness collectively has been a long standing problem in distributed computing. it plays a critical role not only in the design of state-of-the-art byzantine fault-tolerant (bft) and blockchain protocols, but also for a range of applications far beyond this field. we present randrunner, a random beacon protocol with a unique set of guarantees that targets a realistic system model. our design avoids the necessity of a (bft) consensus protocol and its accompanying high complexity and communication overhead. we achieve this by introducing a novel extension to verifiable delay functions (vdfs) in the rsa setting that does not require a trusted dealer or distributed key generation (dkg) and only relies on well studied cryptographic assumptions. this design allows randrunner to tolerate adversarial or failed leaders while guaranteeing safety and liveness of the protocol despite possible periods of asynchrony.", "refining indirect call targets at the binary level": "enforcing fine-grained control-flow integrity (cfi) is critical for increasing software security. however, for commercial off-the-shelf (cots) binaries, constructing high-precision control-flow graphs (cfgs) is challenging, because there is no source-level information, such as symbols and types, to assist in indirect-branch target inference. the lack of source-level information brings extra challenges to inferring targets for indirect calls compared to other kinds of indirect branches. points-to analysis could be a promising solution for this problem, but there is no practical points-to analysis framework for inferring indirect call targets at the binary level. value set analysis (vsa) is the state-of-the-art binary-level points-to analysis but does not scale to large programs. it is also highly conservative by design and thus leads to low-precision cfg construction. in this paper, we present a binary-level points-to analysis framework called bpa to construct sound and high-precision cfgs. it is a new way of performing points-to analysis at the binary level with the focus on resolving indirect call targets. bpa employs several major techniques, including assuming a block memory model and a memory access analysis for partitioning memory into blocks, to achieve a better balance between scalability and precision. in evaluation, we demonstrate that bpa achieves a 34.5% precision improvement rate over the current state-of-the-art technique without introducing false negatives.", "reinforcement learning-based hierarchical seed scheduling for greybox fuzzing": "coverage metrics play an essential role in greybox fuzzing. recent work has shown that fine-grained coverage metrics could allow a fuzzer to detect bugs that cannot be covered by traditional edge coverage. however, fine-grained coverage metrics will also select more seeds, which cannot be efficiently scheduled by existing algorithms. this work addresses this problem by introducing a new concept of multi-level coverage metric and the corresponding reinforcement-learning-based hierarchical scheduler. evaluation of our prototype on darpa cgc showed that our approach outperforms afl and aflfast significantly: it can detect 20% more bugs, achieve higher coverage on 83 out of 180 challenges, and achieve the same coverage on 60 challenges. more importantly, it can detect the same number of bugs and achieve the same coverage faster. on fuzzbench, our approach achieves higher coverage than afl++ (qemu) on 10 out of 20 projects.", "rov++: improved deployable defense against bgp hijacking": "we study and extend route origin validation (rov), the basis for the ietf defenses of interdomain routing. we focus on two important hijack attacks: _subprefix hijacks_ and _non-routed prefix hijacks_.  for both attacks, we  show that, with partial deployment, rov provides disappointing security benefits. we also present _superprefix hijacks_, which completely circumvent rov's defense for non-routed prefix hijacks, and significantly circumvents it for (announced) prefix hijacks. \nwe then present rov++, a novel extension of rov, with significantly improved security benefits even with partial adoption. for example, with uniform 5% adoption for edge ases (ases with no customers or peers), rov prevents less than 5% of subprefix hijacks while rov++ prevents more than 90% of subprefix hijacks.   rov++ also defends well against non-routed prefix attacks and the novel superprefix attacks. \nwe evaluated several rov++ variants, all sharing the improvements in defense; this includes \"lite\", _software-only_ variants, deployable with existing routers. our evaluation is based on extensive simulations over the internet topology.\nwe also expose an obscure yet important aspect of bgp, much amplified by rov: _inconsistencies_ between the observable bgp path (control-plane) and the actual traffic flows (data-plane). these inconsistencies are highly relevant for security, and often lead to a challenge we refer to as _hidden hijacks_.", "serialdetector: principled and practical exploration of object injection vulnerabilities for the web": "the last decade has seen a proliferation of code-reuse attacks in the context of web applications. these attacks stem from object injection vulnerabilities (oiv) enabling attacker-controlled data to abuse legitimate code fragments within a web application's codebase to execute a code chain (gadget) that performs malicious computations, like remote code execution, on attacker's behalf. oivs occur when untrusted data is used to instantiate an object of attacker-controlled type with attacker-chosen properties, thus triggering the execution of code available but not necessarily used by the application. in the web application domain, oivs may arise during the process of deserialization of client-side data, e.g., http requests, when reconstructing the object graph that is subsequently processed by the backend applications on the server side. \nthis paper presents the first systematic approach for detecting and exploiting oivs in .net applications including the framework and libraries. our key insight is: the root cause of oivs is the untrusted information flow from an application's public entry points (e.g., http request handlers) to sensitive methods that create objects of arbitrary types (e.g., reflection apis) to invoke methods (e.g., native/virtual methods) that trigger the execution of a gadget. drawing on this insight, we develop and implement serialdetector, a taint-based dataflow analysis that discovers oiv patterns in .net assemblies automatically. we then use these patterns to match publicly available gadgets and to automatically validate the feasibility of oiv attacks. we demonstrate the effectiveness of our approach by an in-depth evaluation of a complex production software such as the azure devops server. we describe the key threat models and report on several remote code execution vulnerabilities found by serialdetector, including three cves on azure devops server. we also perform an in-breadth security analysis of recent publicly available cves. our results show that serialdetector can detect oivs effectively and efficiently. we release our tool publicly to support open science and encourage researchers and practitioners explore the topic further.", "shadow attacks: hiding and replacing content in signed pdfs": "digitally signed pdfs are used in contracts and invoices to guarantee the authenticity and integrity of their content. a user opening a signed pdf expects to see a warning in case of *any* modification. in 2019, mladenov et al. revealed various parsing vulnerabilities in pdf viewer implementations. they showed attacks that could modify pdf documents without invalidating the signature. as a consequence, affected vendors of pdf viewers implemented countermeasures preventing *all* attacks.\nthis paper introduces a novel class of attacks, which we call *shadow* attacks. the *shadow* attacks circumvent all existing countermeasures and break the integrity protection of digitally signed pdfs. compared to previous attacks, the *shadow* attacks do not abuse implementation issues in a pdf viewer. in contrast, *shadow* attacks use the enormous flexibility provided by the pdf specification so that *shadow* documents remain standard-compliant. since *shadow* attacks abuse only legitimate features, they are hard to mitigate.\nour results reveal that 16 (including adobe acrobat and foxit reader) of the 29 pdf viewers tested were vulnerable to *shadow* attacks. we introduce our tool *pdf-attacker* which can automatically generate *shadow* attacks. in addition, we implemented *pdf-detector* to prevent *shadow* documents from being signed or forensically detect exploits after being applied to signed pdfs.", "soda: a generic online detection framework for smart contracts": "smart contracts have become lucrative and profitable targets for attackers because they can hold a great amount of money. although there are already many studies to discover the vulnerabilities in smart contracts, they can neither guarantee discovering all vulnerabilities nor protect the deployed smart ontracts against the attacks, because they rely on offline analysis. recently, a few online protection approaches appeared but they only focus on specific attacks and cannot be easily extended to defend against other attacks. developing a new online protection system for smart contracts from scratch is time-consuming and requires being familiar with the internals of smart contract runtime, thus making it difficult to quickly implement and deploy mechanisms to defend against new attacks. \nin this paper, we propose a novel generic runtime protection framework named spa for smart contracts on any blockchains that support ethereum virtual machine (evm). spa distinguishes itself from existing online protection approaches through its capability, efficiency, and compatibility. first, spa empowers users to easily develop and deploy protection apps for defending against various attacks by separating the information collection, attack detection and reaction with layered design. at the higher layer, spa provides unified interfaces to develop protection apps gainst various attacks. at the lower layer, spa instruments evm to collect all primitive information necessary to detect various attacks and constructs 11 kinds of structural information for the ease of developing protection apps.\nbased on spa, users can develop new rotection apps in a few lines of code without modifying evm and easily deploy them to the blockchain. second, spa is efficient, because we design on-demand information retrieval to reduce the overhead of information collection and adopt dynamic linking to eliminate the overhead of inter-process communication (ipc). it allows users to develop protection apps by using any programming languages that can generate dynamic link libraries (dlls). third, since more and more blockchains adopt evm as smart contract runtime, spa can be easily migrated to such blockchains without modifying the protection apps. based on spa, we develop 8 protection apps to defend against the attacks exploiting major vulnerabilities in smart contracts, and integrate spa (including all protection apps) into 3 popular blockchains: ethereum, expanse and wanchain. the extensive experimental results demonstrate the effectiveness and efficiency of spa and our protection apps.", "spectaint: speculative taint analysis for discovering spectre gadgets": "software patching is a crucial mitigation approach against spectre-type attacks. it utilizes serialization instructions to disable speculative execution of potential spectre gadgets in a program. unfortunately, there are no effective solutions to detect gadgets for spectre-type attacks. in this paper, we propose a novel spectre gadget detection technique by enabling dynamic taint analysis on speculative execution paths. to this end, we simulate and explore speculative execution at the system level (within a cpu emulator). we have implemented a prototype called spectaint to demonstrate the efficacy of our proposed approach. we evaluated spectaint on our spectre samples dataset, and compared spectaint with existing state-of-the-art spectre gadget detection approaches on real-world applications. our experimental results demonstrate that spectaint outperforms existing methods with respect to detection precision and recall by large margins, and it also detects new spectre gadgets in real-world applications such as caffe and brotli. besides, spectaint significantly reduces the performance overhead after patching the detected gadgets, compared with other approaches.", "squirrl: automating attack analysis on blockchain incentive mechanisms with deep reinforcement learning": "incentive mechanisms are central to the functionality of permissionless blockchains: they incentivize participants to run and secure the underlying consensus protocol. designing incentive-compatible incentive mechanisms is notoriously challenging, however. as a result, most public blockchains today use incentive mechanisms whose security properties are poorly understood and largely untested. in this work, we propose squirrl, a framework for using deep reinforcement learning to analyze attacks on blockchain incentive mechanisms. we demonstrate squirrl\u2019s power by \ufb01rst recovering known attacks: (1) the optimal sel\ufb01sh mining attack in bitcoin [52], and (2) the nash equilibrium in block withholding attacks [16]. we also use squirrl to obtain several novel empirical results. first, we discover a counterintuitive \ufb02aw in the widely used rushing adversary model when applied to multi-agent markov games with incomplete information. second, we demonstrate that the optimal sel\ufb01sh mining strategy identi\ufb01ed in [52] is actually not a nash equilibrium in the multi-agent sel\ufb01sh mining setting. in fact, our results suggest (but do not prove) that when more than two competing agents engage in sel\ufb01sh mining, there is no pro\ufb01table nash equilibrium. this is consistent with the lack of observed sel\ufb01sh mining in the wild. third, we \ufb01nd a novel attack on a simpli\ufb01ed version of ethereum\u2019s \ufb01nalization mechanism, casper the friendly finality gadget (ffg) that allows a strategic agent to amplify her rewards by up to 30%. notably, [10] shows that honest voting is a nash equilibrium in casper ffg; our attack shows that when casper ffg is composed with sel\ufb01sh mining, this is no longer the case. altogether, our experiments demonstrate squirrl\u2019s \ufb02exibility and promise as a framework for studying attack settings that have thus far eluded theoretical and empirical understanding.", "symqemu: compilation-based symbolic execution for binaries": "symbolic execution is a powerful technique for software analysis and bug detection. compilation-based symbolic execution is a recently proposed flavor that has been shown to improve the performance of symbolic execution significantly when source code is available. we demonstrate a novel technique to enable compilation-based symbolic execution of binaries (i.e., without the need for source code). our system, symqemu, builds on top of qemu, modifying the intermediate representation of the target program before translating it to the host architecture. this enables symqemu to compile symbolic-execution capabilities into binaries and reap the associated performance benefits while maintaining architecture independence.\nwe present our approach and implementation, and we show that it outperforms the state-of-the-art binary symbolic executors s2e and qsym with statistical significance; on some benchmarks, it even achieves better performance than the source-based symcc. moreover, our tool has found a previously unknown vulnerability in the well-tested libarchive library, demonstrating its utility in testing real-world software.", "tales of favicons and caches: persistent tracking in modern browsers": "the privacy threats of online tracking have garnered considerable attention in recent years from researchers and practitioners alike. this has resulted in users becoming more privacy-cautious and browser vendors gradually adopting countermeasures to mitigate certain forms of cookie-based and cookie-less tracking. nonetheless, the complexity and feature-rich nature of modern browsers often lead to the deployment of seemingly innocuous functionality that can be readily abused by adversaries. in this paper we introduce a novel tracking mechanism that misuses a simple yet ubiquitous browser feature: favicons. in more detail, a website can track users across browsing sessions by storing a tracking identifier as a set of entries in the browser\u2019s dedicated favicon cache, where each entry corresponds to a specific subdomain. in subsequent user visits the website can reconstruct the identifier by observing which favicons are requested by the browser while the user is automatically and rapidly redirected through a series of subdomains. more importantly, the caching of favicons in modern browsers exhibits several unique characteristics that render this tracking vector particularly powerful, as it is persistent (not affected by users clearing their browser data), non-destructive (reconstructing the identifier in subsequent visits does not alter the existing combination of cached entries), and even crosses the isolation of the incognito mode. we experimentally evaluate several aspects of our attack, and present a series of optimization techniques that render our attack practical. we find that combining our favicon- based tracking technique with immutable browser-fingerprinting attributes that do not change over time allows a website to reconstruct a 32-bit tracking identifier in 2 seconds. furthermore, our attack works in all major browsers that use a favicon cache, including chrome and safari. due to the severity of our attack we propose changes to browsers\u2019 favicon caching behavior that can prevent this form of tracking, and have disclosed our findings to browser vendors who are currently exploring appropriate mitigation strategies.", "tase: reducing latency of symbolic execution with transactional memory": "we present the design and implementation of a tool called tase that uses transactional memory to reduce the latency of symbolic-execution applications with small amounts of symbolic state.\n execution paths are executed natively while operating on concrete values, and only when execution encounters symbolic values (or modeled functions) is native execution suspended and interpretation begun.  execution then returns to its native mode when symbolic values are no longer encountered.  the key innovations in the design of tase are a technique for amortizing the cost of checking whether values are symbolic over few instructions, and the use of hardware-supported transactional memory (tsx) to implement native execution that rolls back with no effect when use of a symbolic value is detected (perhaps belatedly).  we show that tase has the potential to dramatically improve some latency-sensitive applications of symbolic execution, such as methods to verify the behavior of a client in a client-server application.", "the bluetooth cyborg: analysis of the full human-machine passkey entry ake protocol": "in this paper, we  computationally analyze passkey entry in its entirety as a cryptographic authenticated key exchange (ake) -- including user-protocol interactions that are typically ignored as out-of-band. to achieve this, we model the user-to-device channels, as well as the typical device-to-device channel, and adversarial control scenarios in both cases. in particular, we separately capture adversarial control of device displays on the initiating and responding devices as well as adversarial control of user input mechanisms using what we call a cyborg model. the cyborg model enables realistic real-world security analysis in light  of published attacks on user-mediated protocols such as bluetooth that leverage malware and device displays. in light of this, we show that  all versions of passkey entry fail to provide security in our model. finally, we demonstrate how slight modifications to the protocol would allow it to achieve stronger security guarantees for all current variants of passkey generation, as well as a newly proposed twofold mode of generation we term dual passkey entry. these proof-of-concept modifications point to improved design approaches for user-mediated protocols. finally, this work points to categories of vulnerabilities, based on compromise type,  that could be exploited in bluetooth passkey entry.", "to err.is human: characterizing the threat of unintended urls in social media": "to make their services more user friendly, online social-media platforms automatically identify text that corresponds to urls and render it as clickable links.\nin this paper, we show that the techniques used by such services to recognize urls are often too permissive and can result in unintended urls being displayed in social network messages. among others, we show that popular platforms (such as twitter) will render text as a clickable url if a user forgets a space after a full stop as the end of a sentence, and the first word of the next sentence happens to be a valid top level domain. attackers can take advantage of these unintended urls by registering the corresponding domains and exposing millions of twitter users to arbitrary malicious content. to characterize the threat that unintended urls pose to social-media users, we perform a large-scale study of unintended urls in tweets over a period of 7 months. by designing a classifier capable of differentiating between intended and unintended urls posted in tweets, we find more than 26k unintended urls posted by accounts with tens of millions of followers. as part of our study, we also register 45 unintended domains and quantify the traffic that attackers can get by merely registering the right domains at the right time. finally, due to the severity of our findings, we propose a lightweight browser extension which can, on the fly, analyze the tweets that users compose and alert them of potentially unintended urls and raise a warning, allowing users to fix their mistake before the tweet is posted.", "towards understanding and detecting cyberbullying in real-world images": "cyberbullying has become widely recognized as a critical social problem plaguing today's internet users. this problem involves perpetrators using internet-based technologies to bully their victims by sharing cyberbullying-related content. to combat this problem, researchers have studied the factors associated with such content and proposed automatic detection techniques based on those factors. however, most of these studies have mainly focused on understanding the factors of textual content, such as comments and text messages, while largely overlooking the misuse of visual content in perpetrating cyberbullying. recent technological advancements in the way users access the internet have led to a new cyberbullying paradigm. perpetrators can use visual media to bully their victims through sending and distributing images with cyberbullying content. as a first step to understand the threat of cyberbullying in images, we report in this paper a comprehensive study on the nature of images used in cyberbullying. we first collect a real-world cyberbullying images dataset with 19,300 valid images. we then analyze the images in our dataset and identify the factors related to cyberbullying images that can be used to build systems to detect cyberbullying in images. our analysis of factors in cyberbullying images reveals that unlike traditional offensive image content (e.g., violence and nudity), the factors in cyberbullying images tend to be highly contextual. we further demonstrate the effectiveness of the factors by measuring several classifier models based on the identified factors. with respect to the cyberbullying factors identified in our work, the best classifier model based on multimodal classification achieves a mean detection accuracy of 93.36% on our cyberbullying images dataset.", "trust the crowd: wireless witnessing to detect attacks on ads-b-based air-traffic surveillance": "automatic dependent surveillance-broadcast (ads-b) has been widely adopted as the de facto standard for air-traffic surveillance. aviation regulations require all aircraft to actively broadcast status reports containing identity, position, and movement information. however, the lack of security measures exposes ads-b to cyberattacks by technically capable adversaries with the purpose of interfering with air safety. in this paper, we develop a non-invasive trust evaluation system to detect attacks on ads-b-based air-traffic surveillance using real-world flight data as collected by an infrastructure of ground-based sensors. taking advantage of the redundancy of geographically distributed sensors in a crowdsourcing manner, we implement verification tests to pursue security by wireless witnessing. at the core of our proposal is the combination of verification checks and machine learning (ml)-aided classification of reception patterns\u2014such that user-collected data cross-validates the data provided by other users. our system is non-invasive in the sense that it neither requires modifications on the deployed hardware nor the software protocols and only utilizes already available data. we demonstrate that our system can successfully detect gps spoofing, ads-b spoofing, and even sybil attacks for airspaces observed by at least three benign sensors. we are further able to distinguish the type of attack, identify affected sensors, and tune our system to dynamically adapt to changing air-traffic conditions.", "uiscope: accurate, instrumentation-free, and visible attack investigation for gui applications": "existing attack investigation solutions for gui applications suffer from a few limitations such as inaccuracy (because of the dependence explosion problem), requiring instrumentation, and providing very low visibility. such limitations have hindered their widespread and practical deployment. in this paper, we present uiscope, a novel accurate, instrumentation-free, and visible attack investigation system for gui applications. the core idea of uiscope is to perform causality analysis on both ui elements/events which represent users' perspective and low-level system events which provide detailed information of what happens under the hood, and then correlate system events with ui events to provide high accuracy and visibility. long running processes are partitioned to individual ui transitions, to which low-level system events are attributed, making the results accurate. the produced graphs contain (causally related) ui elements with which users are very familiar, making them easily accessible. we deployed uiscope on 7 machines for a week, and also utilized uiscope to conduct an investigation of 6 real-world attacks. our evaluation shows that compared to existing works, uiscope introduces negligible overhead (less than 1% runtime overhead and 3.05 mb event logs per hour on average) while uiscope can precisely identify attack provenance while offering users thorough visibility into the attack context.", "understanding and detecting international revenue share fraud": "premium rate phone numbers are often abused by malicious parties (e.g., via various phone scams, mobile malware) as a way to obtain monetary benefit. this benefit comes from the \u2018revenue share\u2019 mechanism that enables the owner of the premium rate number to receive some part of the call revenue for each minute of the call traffic generated towards this number. this work focuses on international revenue share fraud (irsf), which abuses regular international phone numbers as the so-called international premium rate numbers (iprn). irsf often involves multiple parties (e.g., a fraudulent telecom operator in collaboration with a premium rate service provider) who collect and share the call revenue, and is usually combined with other fraud schemes to generate call traffic without payment. although this fraud scheme has been around for several years, it remains to be one of the most common fraud schemes, reportedly leading to billions of dollars of losses every year. in this paper we explore the irsf ecosystem from multiple angles, via: (i) a telephony honeypot that observes irsf attempts towards an unused phone number range (i.e., a phone number gray space), (ii) a dataset of more than 3 million test iprns and more than 206k test call logs we collected from several online iprn service providers during 4 years, and finally, (iii) a real- world call data set from a small european operator, involving 689k call records, that we analyze to find irsf cases. by leveraging our observations from (ii), we propose several machine learning features that can be used in irsf detection. we validate our approach on the dataset in (iii), achieving 98% accuracy with a 0.28% false positive rate in detecting the fraudulent calls.", "understanding the growth and security considerations of ecs": "the domain name system (dns) is fundamental to communication on the internet. therefore, any proposed changes or extensions to dns can have profound consequences on network communications. in this paper, we explore the implications of a recent extension to dns called edns client subnet (ecs). this extension extends the visibility of client information to more domain operators by providing a prefix of a client\u2019s ip address to dns nameservers above the recursive nameserver. this raises numerous questions about the impact of such changes on network communications that rely on dns.\nin this paper, we present the results of a longitudinal study that measures the deployment of ecs using several dns vantage points. we show that, despite being an optional extension, ecs has seen steady adoption over time\u2014even for sites that do not benefit from its use. additionally, we observe that the client subnet provided by ecs may provide less privacy than originally thought, with most subnets corresponding to a /24 cidr or smaller. lastly, we observe several positive and negative consequences resulting from the introduction of dns. for example, dns can help aid security efforts when analyzing dns data above the recursive due to the addition of client network information. however, that same client information has the potential to exacerbate existing security issues like dns leakage. ultimately, this paper discusses how small changes to fundamental protocols can result in unintended consequences that can be both positive and negative.", "understanding worldwide private information collection on android": "mobile phones enable the collection of a wealth of private information, from unique identifiers (e.g., email addresses), to a user\u2019s location, to their text messages. this information can be harvested by apps and sent to third parties, which can use it for a variety of purposes. in this paper we perform the largest study of private information collection (pic) on android to date. leveraging an anonymized dataset collected from the customers of a popular mobile security product, we analyze the flows of sensitive information generated by 2.1m unique apps installed by 17.3m users over a period of 21 months between 2018 and 2019. we find that 87.2% of all devices send private information to at least five different domains, and that actors active in different regions (e.g., asia compared to europe) are interested in collecting different types of information. the united states (62% of the total) and china (7% of total flows) are the countries that collect most private information. our findings raise issues regarding data regulation, and would encourage policymakers to further regulate how private information is used by and shared among the companies and how accountability can be truly guaranteed.", "watson: abstracting behaviors from audit logs via aggregation of contextual semantics": "endpoint monitoring solutions are widely deployed in today\u2019s enterprise environments to support advanced attack detection and investigation. these monitors continuously record system-level activities as audit logs and provide deep visibility into security incidents. unfortunately, to recognize behaviors of interest and detect potential threats, cyber analysts face a semantic gap between low-level audit events and high-level system behaviors. to bridge this gap, existing work largely matches streams of audit logs against a knowledge base of rules that describe behaviors. however, specifying such rules heavily relies on expert knowledge. in this paper, we present watson, an automated approach to abstracting behaviors by inferring and aggregating the semantics of audit events. watson uncovers the semantics of events through their usage context in audit logs. by extracting behaviors as connected system operations, watson then combines event semantics as the representation of behaviors. to reduce analysis workload, watson further clusters semantically similar behaviors and distinguishes the representatives for analyst investigation. in our evaluation against both benign and malicious behaviors, watson exhibits high accuracy for behavior abstraction. moreover, watson can reduce analysis workload by two orders of magnitude for attack investigation.", "who's hosting the block party? studying third-party blockage of csp and sri": "the web has grown into the most widely used application platform for our daily lives.  first-party web applications thrive due to many different third parties they rely on to provide auxiliary functionality, like maps or ads, to their sites. in this paper, we set out to understand to what extent this outsourcing has adverse effects on two key security mechanisms, namely content security policy (csp; to mitigate xss) and subresource integrity (sri; to mitigate third-party compromises) by conducting a longitudinal study over 12 weeks on 10,000 top sites. \nunder the assumption that a first party wants to deploy csp and sri and is able to make their code base compliant with these mechanisms, we assess how many sites could fully deploy the mechanisms without cooperation from their third parties. for those unable to do so without cooperation, we also measure how many third parties would jointly have to make their code compliant to enable first-party usage of csp and sri.\nto more accurately depict trust relations, we rely on holistic views into inclusion chains within all pages of the investigated sites. in addition, based on a combination of heuristics and manual validation, we identify different etld+1s belonging to the same business entity, allowing us to more accurately discerning parties from each other. doing so, we show that the vast majority of sites includes third-party code which necessitates the use of unsafe-inline (75%) or unsafe-eval (61%), or makes deployment of strict-dynamic impossible (76%) without breakage of functionality. for sri, based on the analysis of a single snapshot (within less than 12 hours), we also show that more than half of all sites cannot fully rely on sri to protect them from third-party compromise due to randomized third-party content.", "winnie : fuzzing windows applications with harness synthesis and fast cloning": "fuzzing is an emerging technique to automatically validate programs and uncover bugs. it has been widely used to test many programs and has found thousands of security vulnerabilities. however, existing fuzzing efforts are mainly centered around unix-like systems, as windows imposes unique challenges for fuzzing: a closed-source ecosystem, the heavy use of graphical interfaces and the lack of fast process cloning machinery.\nin this paper, we propose two solutions to address the challenges windows fuzzing faces. our system, winnie, first tries to synthesize a harness for the application, a simple program that directly invokes target functions, based on sample executions. it then tests the harness, instead of the original complicated program, using an efficient implementation of fork on windows. using these techniques, winnie can bypass irrelevant gui code to test logic deep within the application. we used winnie to fuzz 59 closed-source windows binaries, and it successfully generated valid fuzzing harnesses for all of them. in our evaluation, winnie can support 2.2x more programs than existing windows fuzzers could, and identified 3.9x more program states and achieved 26.6x faster execution. in total, winnie found 61 unique bugs in 32 windows binaries.", "your phone is my proxy: detecting and understanding mobile proxy networks": "residential proxy has emerged as a service gaining popularity recently, in which proxy providers relay their customers\u2019 network traffic through millions of proxy peers under their control. we find that many of these proxy peers are mobile devices, whose role in the proxy network can have significant security implications since mobile devices tend to be privacy- and resource-sensitive. however, little effort has been made so far to understand the extent of their involvement, not to mention how these devices are recruited by the proxy network and what security and privacy risks they may pose.\nin this paper, we report the first measurement study on the mobile proxy ecosystem. our study was made possible by a novel measurement infrastructure, which enabled us to identify proxy providers, to discover proxy sdks (software development kits), to detect android proxy apps built upon the proxy sdks, to harvest proxy ip addresses, and to understand proxy traffic. the information collected through this infrastructure has brought to us new understandings of this ecosystem and important security discoveries. more specifically, 4 proxy providers were found to offer app developers mobile proxy sdks as a competitive app monetization channel, with $50k per month per 1m mau (monthly active users). 1,701 android apks (belonging to 963 android apps) turn out to have integrated those proxy sdks, with most of them available on google play with at least 300m installations in total. furthermore, 48.43% of these apks are flagged by at least 5 anti-virus engines as malicious, which could explain why 86.60% of the 963 android apps have been removed from google play by oct 2019. besides, while these apps display user consent dialogs on traffic relay, our user study indicates that the user consent texts are quite confusing. we even discover a proxy sdk that stealthily relays traffic without showing any notifications. we also captured 625k cellular proxy ips, along with a set of suspicious activities observed in proxy traffic such as ads fraud. we have reported our findings to affected parties, offered suggestions, and proposed the methodologies to detect proxy apps and proxy traffic.", "\u0434\u043e\u0432\u0435\u0440\u044f\u0301\u0439, \u043d\u043e \u043f\u0440\u043e\u0432\u0435\u0440\u044f\u0301\u0439: sfi safety for native-compiled wasm": "webassembly (wasm) is a platform-independent bytecode that offers both good performance and runtime isolation. to implement isolation, the compiler inserts safety checks when it compiles wasm to native machine code. while this approach is cheap, it also requires trust in the compiler's correctness---trust that the compiler has inserted each necessary check, correctly formed, in each proper place. unfortunately, subtle bugs in the wasm compiler can break---and emph{have broken}---isolation guarantees. to address this problem, we propose verifying memory isolation of wasm binaries post-compilation. we implement this approach in veriwasm, a static offline verifier for native x86-64 binaries compiled from wasm; we prove the verifier's soundness, and find that it can detect bugs with no false positives. finally, we describe our deployment of veriwasm at fastly."}